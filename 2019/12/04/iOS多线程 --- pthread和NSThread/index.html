<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="好奇 专注 保持进步"><title>iOS多线程 --- pthread和NSThread | 刘渣渣的Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS多线程 --- pthread和NSThread</h1><a id="logo" href="/.">刘渣渣的Blog</a><p class="description">好奇 专注 保持进步</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS多线程 --- pthread和NSThread</h1><div class="post-meta">Dec 4, 2019</div><a class="disqus-comment-count" href="/2019/12/04/iOS多线程 --- pthread和NSThread/#vcomment"><span class="valine-comment-count" data-xid="/2019/12/04/iOS多线程 --- pthread和NSThread/"></span><span> Comment</span></a><div class="post-content"><p>多线程，是实现多个线程并发执行的技术，对于单核CPU来说，虽然在硬件的限制下同时只能执行一个线程，但是操作系统可以快速的在不同线程之间切换，在很小的切换时间下，来给用户造成一种同时运行多个线程的假象，而对于多核CPU，因为有硬件的支持而能够在同一时间同时运行多个线程<br>iOS中有以下几种线程方案</p>
<ol>
<li>Pthread</li>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperationQueue</li>
</ol>
<h2 id="Pthread"><a href="#Pthread" class="headerlink" title="Pthread"></a>Pthread</h2><p>Pthread是一套通用的多线程方案，可以在类Unix操作系统（如Unix，Linux，Mac OS)等系统使用，它使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，在开发中几乎不会直接使用它。</p>
<p>使用pthread创建一个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//声明一个thread变量</span><br><span class="line">pthread_t thread;</span><br><span class="line"></span><br><span class="line">//创建并开启thread，执行test函数</span><br><span class="line">pthread_create(&amp;thread, NULL, test, NULL);</span><br><span class="line"></span><br><span class="line">//设置该线程的状态为detach，使该线程执行结束后自动释放所有资源</span><br><span class="line">pthread_detach(thread);</span><br><span class="line">NSLog(@&quot;Current Thread1:%@&quot;, [NSThread currentThread]); //打印结果：Current Thread1:&lt;NSThread: 0x60000360acc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br><span class="line">void *test(void *param)&#123;</span><br><span class="line">    NSLog(@&quot;Current Thread12:%@&quot;, [NSThread currentThread]);//打印结果：Current Thread1:&lt;NSThread: 0x60000361ad00&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-12-04 21:37:25.502129+0800 Thread[2601:163643] Current Thread2:&lt;NSThread: 0x600002aa5040&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2019-12-04 21:37:25.503243+0800 Thread[2601:163558] Current Thread1:&lt;NSThread: 0x600002ad5040&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在pthread中通过pthread_create函数来创建线程，pthread_create(&amp;thread, NULL, test, NULL)有四个参数,各项参数含义如下：</p>
<p>第一个参数：指向线程（标识符）的指针<br>第二个参数：用来设置线程属性  ，通常设置为NULL<br>第三个参数：线程运行的函数地址<br>第四个参数：运行函数的参数<br>其中第一、二个参数比较简单，这里再额外介绍一下第三四个参数，<br>第三个参数”线程属性“是一个pthread_attr_t类型的结构体，这个结构体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">    &#123;</span><br><span class="line">        int detachstate;   //线程的分离状态</span><br><span class="line">        int schedpolicy;   //线程调度策略</span><br><span class="line">        struct sched_param schedparam;  //线程的调度参数</span><br><span class="line">        int inheritsched;  //线程的继承性</span><br><span class="line">        int scope;         //线程的作用域</span><br><span class="line">        size_t guardsize;  //线程栈末尾的警戒缓冲区大小</span><br><span class="line">        int stackaddr_set;</span><br><span class="line">        void *stackaddr;   //线程栈的位置</span><br><span class="line">        size_t stacksize;  //线程栈的大小</span><br><span class="line">&#125;pthread_attr_t;</span><br></pre></td></tr></table></figure></p>
<p>要使用pthread_attr_t我们需要对它进行初始化，使用后还要去初始化<br>pthread_attr_t初始化函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_attr_init()</span><br></pre></td></tr></table></figure></p>
<p>pthread_attr_t去初始化函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_attr_destory()</span><br></pre></td></tr></table></figure></p>
<p>pthread_attr_init之后，pthread_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值</p>
<p>如果想修改这些默认值，pthread_attr_t的每一个属性都有相应的函数对其进行查看和修改</p>
<p>比如修改分离状态可以用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_attr_getdetachstate(const pthread_attr_t * attr, int * detachstate);</span><br><span class="line">int pthread_attr_setdetachstate(pthread_attr_t * attr, int detachstate);</span><br></pre></td></tr></table></figure></p>
<p>设置的时候可以有两种选择：<br>            <1>.detachstate参数为：PTHREAD_CREATE_DETACHED     分离状态启动<br>            <2>.detachstate参数为：PTHREAD_CREATE_JOINABLE    正常启动线程</2></1></p>
<p>线程的继承性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_attr_getinheritsched(const pthread_attr_t *attr,int *inheritsched);</span><br><span class="line">int pthread_attr_setinheritsched(pthread_attr_t *attr,int inheritsched);</span><br></pre></td></tr></table></figure></p>
<p>参数支持：<br> PTHREAD_INHERIT_SCHED： 新的线程继承创建线程的策略和参数<br> PTHREAD_EXPLICIT_SCHED：新的线程继承策略和参数来自于 schedpolicy和schedparam属性中显式 设置的调度信息</p>
<p> pthread_attr_t的其他属性都有相应的函数来修改，这里就不一一介绍了，感兴趣的同学可以在stackoverflow的<a href="https://stackoverflow.com/questions/43022867/when-pthread-attr-t-is-not-null" title="when pthread_attr_t is not NULL?" target="_blank" rel="noopener">when pthread_attr_t is not NULL?</a>问题中了解到更多信息</p>
<p> 第四个参数：<br>运行函数传递的参数，当传递单个参数时，可以直接定义一个变量传递给线程函数，当需要传递多个参数时候，就需要创建一个结构体来包含所有的参数，然后再传入线程函数：</p>
<p>传单个参数的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义一个函数</span><br><span class="line">void *test(void *param)&#123;</span><br><span class="line">    NSLog(@&quot;test:%d&quot;, *(int *)param);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明变量，创建线程，调用函数传递参数</span><br><span class="line">int i = 100;</span><br><span class="line">pthread_create(&amp;thread, NULL, test, &amp;i);</span><br><span class="line">pthread_detach(thread);</span><br></pre></td></tr></table></figure>
<p>传多个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//定义一个结构体</span><br><span class="line">struct parameters&#123;</span><br><span class="line">    int size;</span><br><span class="line">    int count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//定义函数</span><br><span class="line">void *test(void *param)&#123;</span><br><span class="line">    struct paramaters *args;</span><br><span class="line">    args = (struct paramaters *)param;</span><br><span class="line">    NSLog(@&quot;test:size:%d， count:%d&quot;, args-&gt;size, args-&gt;count);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明结构体变量，结构体赋值，创建线程，调用函数传递参数</span><br><span class="line">struct paramaters args;</span><br><span class="line">args.size = 100;</span><br><span class="line">args.count = 300;</span><br><span class="line">pthread_create(&amp;thread, NULL, test, &amp;args);</span><br><span class="line">pthread_detach(thread);</span><br></pre></td></tr></table></figure>
<p>除了pthread_create，Pthread 还有以下相关函数：</p>
<ul>
<li>pthread_exit() 终止当前线程</li>
<li>pthread_cancel() 中断另外一个线程的运行</li>
<li>pthread_join() 阻塞当前的线程，直到另外一个线程运行结束</li>
<li>pthread_attr_init() 初始化线程的属性</li>
<li>pthread_attr_setdetachstate() 设置脱离状态的属性（决定这个线程在终止时是否可以被结合）</li>
<li>pthread_attr_getdetachstate() 获取脱离状态的属性</li>
<li>pthread_attr_destroy() 删除线程的属性</li>
<li>pthread_kill() 向线程发送一个信号</li>
</ul>
<p>我们通常并不会直接使用pthread来管理线程，所以对pthread不再做过多的介绍</p>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>NSThread和pthread都是对内核 mach kernal的mach thread的封装，不同的是NSThread是由苹果官方提供的，可以直接操作线程对象，使用起来比pthread更加易用，不过仍需要自己管理生命周期、同步、加锁的问题</p>
<p>创建线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//先创建线程，再启动线程</span><br><span class="line">NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(sailTickets) object:nil];</span><br><span class="line">[thread start];</span><br><span class="line">//先创建线程后自动启动线程</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(test) toTarget:self withObject:nil];</span><br><span class="line">//隐式创建并启动线程</span><br><span class="line">[self performSelectorInBackground:@selector(test) withObject:nil];</span><br></pre></td></tr></table></figure></p>
<p>线程相关方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获得主线程</span><br><span class="line">+ (NSThread *)mainThread;    </span><br><span class="line">// 判断是否为主线程(对象方法)</span><br><span class="line">- (BOOL)isMainThread;</span><br><span class="line">// 判断是否为主线程(类方法)</span><br><span class="line">+ (BOOL)isMainThread;    </span><br><span class="line">// 获得当前线程</span><br><span class="line">NSThread *current = [NSThread currentThread];</span><br><span class="line">// 线程的名字——setter方法</span><br><span class="line">- (void)setName:(NSString *)n;    </span><br><span class="line">// 线程的名字——getter方法</span><br><span class="line">- (NSString *)name;</span><br></pre></td></tr></table></figure></p>
<p>线程状态控制方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)start;// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span><br><span class="line">+ (void)sleepUntilDate:(NSDate *)date;// 线程进入阻塞状态</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 线程进入阻塞状态</span><br><span class="line">+ (void)exit;// 线程进入死亡状态</span><br></pre></td></tr></table></figure></p>
<p>线程之间的通信<br>在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在主线程上执行操作</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray&lt;NSString *&gt; *)array;</span><br><span class="line"></span><br><span class="line">// 在指定线程上执行操作</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span><br><span class="line">- (id)performSelector:(SEL)aSelector;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</span><br></pre></td></tr></table></figure>
<p>线程的五个状态<br>New  Runnabled  Running  Blocked  Dead</p>
<p>New:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadDemo) object:nil];</span><br></pre></td></tr></table></figure></p>
<p>Runnabled：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[thread start];</span><br></pre></td></tr></table></figure></p>
<p>Running<br>CPU负责调度可调度线程池中的处于就绪状态的线程，线程在执行结束之前，状态可能在就绪和运行之间来回的切换，就绪和运行之间的状态切换由CPU来完成，我们无法干涉</p>
<p>阻塞<br>正在运行的线程，当满足某个条件时，可以用休眠或者锁来阻塞线程的执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//sleepForTimeInterval:休眠指定时长</span><br><span class="line">[NSThread sleepForTimeInterval:1.0];</span><br><span class="line">//sleepUntilDate:休眠到指定日期</span><br><span class="line">[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]];</span><br><span class="line">//互斥锁</span><br><span class="line">@synchronized(self)</span><br></pre></td></tr></table></figure></p>
<p>Dead<br>线程正常死亡：线程执行结束<br>线程非正常死亡：线程突然崩溃/当满足某个条件后，在线程内部强制退出，调用exit方法</p>
<p>关于exit需要注意的地方：<br>不能在主线程中调用该方法.会使主线程退出.<br>当当前线程死亡之后,这个线程中的代码都不会被执行.<br>在调用此方法之前一定要注意释放之前由C语言框架创建的对象</p>
<p>线程状态的转换<br>当我们创建了一个线程，执行start方法后，系统把线程放入可调度线程池中，此时线程进入就绪（Runnabled）状态<br>如果CPU调度当前线程，则当前线程进入运行状态，当CPU调度其他线程，则当前线程回到就绪状态<br>如果系统在运行当前线程时候调用了sleep方法/等待同步锁，则当前线程进入阻塞状态，等到sleep到时/得到同步锁，则回到就绪状态<br>如果系统在运行当前线程对象的时候线程任务执行完毕/异常强制退出，则当前线程对象进入死亡状态</p>
<p>线程常驻<br>在一些场景中需要用到常驻线程，要使线程常驻就需要用到RunLoop，每个线程都有一个RunLoop这是默认没有开启，RunLoop的开启就意味着线程的常驻，比如主线程</p>
<p>下边这段代码来自AFNetworking<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的_networkRequestThread就属于常驻线程，可以看到要想创建一个常驻线程，只要以下几步：<br>1.创建一个全局的thread变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSThread *networkThread;</span><br></pre></td></tr></table></figure></p>
<p>2.初始化线程并启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.networkThread = [[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">[self.networkThread start];</span><br></pre></td></tr></table></figure></p>
<p>3.在线程中开启RunLoop，子线程中的RunLoop是默认关闭的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在networkThread已经实现了常驻，当需要使用它的时候可以这么调用<br>4.利用常驻线程处理任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(action) onThread:self.networkThread withObject:nil waitUntilDone:NO ];</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2019/04/23/栈的最佳实践-打造一个逆波兰计算器/">栈的最佳实践 - 打造一个逆波兰计算器</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'nu5iv8I7XfqMRqsPlXpcDKEe-gzGzoHsz',
  appKey:'iVSeGxiMcvCazRicwJuHKWts',
  placeholder:'请输入评论',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.cocoathinking.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/iOS9/" style="font-size: 15px;">iOS9</a> <a href="/tags/Search-API/" style="font-size: 15px;">Search API</a> <a href="/tags/NSUserActivity/" style="font-size: 15px;">NSUserActivity</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/04/iOS多线程 --- pthread和NSThread/">iOS多线程 --- pthread和NSThread</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/栈的最佳实践-打造一个逆波兰计算器/">栈的最佳实践 - 打造一个逆波兰计算器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/22/iOS中Active与JS的交互/">iOS中Active与JS的交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/weak-strong-dance/">weak-strong dance</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/block/">block</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/pomera/">pomera</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/翻译：ReactiveCocoa-for-a-better-world/">翻译：ReactiveCocoa for a better world</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/25/fastlane/">fastlane</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/2-常用操作和高阶函数/">Reactivecocoa全解析 2.常用操作和高阶函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/1-FRP编程思想/">Reactivecocoa全解析 1.FRP编程思想</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://dulingkang.github.io" title="shawnDu" target="_blank">shawnDu</a><ul></ul><a href="www.wendao.info" title="张省三" target="_blank">张省三</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">刘渣渣的Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>