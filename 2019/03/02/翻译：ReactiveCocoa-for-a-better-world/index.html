<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="好奇 专注 保持进步"><title>翻译：ReactiveCocoa for a better world | 刘渣渣的Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">翻译：ReactiveCocoa for a better world</h1><a id="logo" href="/.">刘渣渣的Blog</a><p class="description">好奇 专注 保持进步</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">翻译：ReactiveCocoa for a better world</h1><div class="post-meta">Mar 2, 2019</div><a class="disqus-comment-count" href="/2019/03/02/翻译：ReactiveCocoa-for-a-better-world/#vcomment"><span class="valine-comment-count" data-xid="/2019/03/02/翻译：ReactiveCocoa-for-a-better-world/"></span><span> Comment</span></a><div class="post-content"><p><strong>ReactiveCocoa创造更美好的世界</strong><br><strong>原文：<a href="https://github.blog/2012-05-04-reactivecocoa-for-a-better-world/#async" target="_blank" rel="noopener">ReactiveCocoa for a better world</a></strong></p>
<blockquote>
<p>首先说一下为什么要翻译这篇2012年的文章。ReactiveCocoa for a better world是由<a href="https://github.blog/author/joshaber/" target="_blank" rel="noopener">Josh Abernathy</a>在2012年发表，那个时间刚好是ReactiveCocoa开源的时间，而作者<a href="https://github.blog/author/joshaber/" target="_blank" rel="noopener">Josh Abernathy</a>正是这一开源框架的主要作者，在这篇文章中Josh Abernathy从多个角度为我们介绍了为什么要使用ReactiveCocoa以及ReactiveCocoa能为我们做什么，在这篇文章中你可能会看到一些其他介绍ReactiveCocoa文章的影子，或者更应该说是在一些其他的关于ReactiveCocoa文章中看到ReactiveCocoa for a better world的影子。因为它的影响太深了，在时隔多年重新看到它后我有了把它翻译成中文的想法。</p>
</blockquote>
<p>原生App花费了大量的时间来等待和响应，我们等待用户在UI界面上做一些操作，等待网络请求返回响应，等待异步操作的完成，等待一些依赖数据发生改变，然后做出响应。</p>
<p>但是所有的这些事情-所有的这些等待和响应-通常都会有许多不同的处理方式，这让我们在使用统一的方法来推断他们，chain them，或者是完成它们来变得非常困难。其实，我们可以通过高级方法来做的更好。</p>
<p>这就为什么我们开源这个神奇的魔法：<a href="https://desktop.github.com/" target="_blank" rel="noopener"> GitHub for Mac: </a> :<a href="https://github.com/ReactiveCocoa/ReactiveCocoaRAC" target="_blank" rel="noopener">ReactiveCocoa</a></p>
<p>RAC是一个<strong>组合和转换序列值得框架。</strong></p>
<h2 id="认真讲，他是什么？"><a href="#认真讲，他是什么？" class="headerlink" title="认真讲，他是什么？"></a>认真讲，他是什么？</h2><hr>
<p>让我们来看一些干货，RAC给我们带来了很多非常酷的东西：</p>
<ol>
<li>组合操作一些未来数据的能力</li>
<li>最小化的使用状态量和可变数据的能力</li>
<li>用一种方式定义行为和属性之间的联系</li>
<li>一个统一的，更高级的异步操作接口</li>
<li>在KVO之上封装的友好的API</li>
</ol>
<p>这些功能看起来可能像是随机的，直到你了解到RAC可以处理这些包含了将要等待的一些新值和响应的所有事件。</p>
<p>最美妙的地方在于RAC是那个能够适应许多不同的，常见的场景。<br>说了这么多，让我们来看看RAC实际上的样子</p>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><hr>
<p>RAC可以将遵循了<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html" target="_blank" rel="noopener">KVO-compliant</a>属性利用<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="noopener">KVO(key-value observing)</a>l来带来序列的值.举个例子，我们可以看到username属性的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RACAble(self.username) subscribeNext:^(NSString *newName) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, newName);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>That’s cool,但是如果只有这些，那它只是一个比KOV更友好的API，RAC最酷的地方在于我们可以组合序列来一表示一些复杂的行为。<br>假设我们想要检查用户输入的一个特殊用户名，当用用户输入前三个值之内的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[[RACAble(self.username)</span><br><span class="line">distinctUntilChanged]</span><br><span class="line">take:3]</span><br><span class="line">filter:^(NSString *newUsername) &#123;</span><br><span class="line">return [newUsername isEqualToString:@&quot;joshaber&quot;];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeNext:^(id _) &#123;</span><br><span class="line">NSLog(@&quot;Hi me!&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>我们发现username发生了变化，使用filter过滤发生的变化，使用take取前三个发生变化的值，如果新值是joshaber,我们就打印一个“hi mi</p>
<h3 id="所以呢？"><a href="#所以呢？" class="headerlink" title="所以呢？"></a>所以呢？</h3><hr>
<p>考虑一下，如果我们不使用RAC来完成这个操作，我们将不得不：</p>
<ul>
<li>为username添加上KVO进行监听</li>
<li>添加一个属性来记住我们通过KVO监听到的发生变化的最后一个值</li>
<li>添加一个属性来记录我们接收到了多少个发生了变化的值</li>
<li>任何时间获取到发生变化的值得时候都要添加属性</li>
<li>对数据进行比较</li>
</ul>
<h3 id="还有其他的么？"><a href="#还有其他的么？" class="headerlink" title="还有其他的么？"></a>还有其他的么？</h3><p>我们可以组合序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal</span><br><span class="line">combineLatest:@[ RACAble(self.password), RACAble(self.passwordConfirmation) ]</span><br><span class="line">reduce:^(NSString *currentPassword, NSString *currentConfirmPassword) &#123;</span><br><span class="line">return [NSNumber numberWithBool:[currentConfirmPassword isEqualToString:currentPassword]];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeNext:^(NSNumber *passwordsMatch) &#123;</span><br><span class="line">self.createEnabled = [passwordsMatch boolValue];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>当任何时间password和passwordConfirmation发生变化的时候，我们组合这两个属性最后的值，然后判断这两个值是否符合我们的要求，最后返回一个BOOL。我们就可以通过这个BOOL结果来设置button是否可以点击</p>
<h3 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h3><p>We can adapt RAC to give us powerful bindings with conditions and transformations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RAC(self, help) = [[RACObserve(self.helpLabel, text) filter:^(NSString *newHelp)&#123;</span><br><span class="line">return newHelp != nil;</span><br><span class="line">&#125;] map:^(NSString *newHelp)&#123;</span><br><span class="line">return [newHelp uppercaseString];</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>绑定help label的值得到属性help上，当流出的新值不是nil，就将这个新值转换成小写。（因为用户总喜欢being YELLED AT）、</p>
<h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><p>RAC同样非常适合做异步操作</p>
<p>举个例子，我们通过调用一个block来完成多次并发操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal</span><br><span class="line">merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]]</span><br><span class="line">subscribeCompleted:^&#123;</span><br><span class="line">NSLog(@&quot;They&apos;re both done!&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>或是链式调用异步操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[[[client</span><br><span class="line">loginUser]</span><br><span class="line">flattenMap:^(id _) &#123;</span><br><span class="line">return [client loadCachedMessages];</span><br><span class="line">&#125;]</span><br><span class="line">flattenMap:^(id _) &#123;</span><br><span class="line">return [client fetchMessages];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeCompleted:^&#123;</span><br><span class="line">NSLog(@&quot;Fetched all messages.&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>用户登录后，首先加载缓存的消息，然后获取远程的消息，然后打印“Fetched all messages”</p>
<p>我们也可以方便的讲执行的操作移动到background queue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[[[[client</span><br><span class="line">fetchUserWithUsername:@&quot;joshaber&quot;]</span><br><span class="line">deliverOn:[RACScheduler scheduler]]</span><br><span class="line">map:^(User *user) &#123;</span><br><span class="line">// this is on a background queue</span><br><span class="line">return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];</span><br><span class="line">&#125;]</span><br><span class="line">deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">subscribeNext:^(NSImage *image) &#123;</span><br><span class="line">// now we&apos;re back on the main queue</span><br><span class="line">self.imageView.image = image;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>或者可以更简单的处理潜在的竞争条件，比如，我们可以使用异步操作中通过结果来更新属性，但是除非这个属性在异步操作完成前没有发生变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[[self</span><br><span class="line">loadDefaultMessageInBackground]</span><br><span class="line">takeUntil:RACAble(self.message)]</span><br><span class="line">toProperty:@keypath(self.message) onObject:self];</span><br></pre></td></tr></table></figure></p>
<h3 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h3><p>RAC从根本上来看是非常简单的，它是以信号的方式来流转数据。<a href="https://cvaieee.org/html/humor/programming_history.html" target="_blank" rel="noopener">Until you reach turtles.</a></p>
<p>Subscribers来订阅signals，Signals为它的订阅者发送 ’next’, ‘error’, ‘completed’事件，如果所有的事情都是signals来发送时间，那么关键的问题就编程了：这些事件会在什么时候被发送？</p>
<h3 id="Creating-Signals"><a href="#Creating-Signals" class="headerlink" title="Creating Signals"></a>Creating Signals</h3><p>信号根据合适发送时间来定义自己的行为，我们可以通过+[RACSignal createSignal:]来创建自己的signal：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *helloWorld = [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:@&quot;Hello, &quot;];</span><br><span class="line">[subscriber sendNext:@&quot;world!&quot;];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">return nil;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>当这个signal获取一个新的订阅者，+[RACSignal createSignal:]会通过这个block进行回调。这个新的订阅者是通过里边的block我们可以发送这个事件。在上边的例子中，我们创建了一个signal会发送一个“hello”和“world”,然后发送完成。</p>
<h2 id="嵌套signal"><a href="#嵌套signal" class="headerlink" title="嵌套signal"></a>嵌套signal</h2><p>我们可以基于helloWorld signal来创建另一个signal：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *joiner = [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">NSMutableArray *strings = [NSMutableArray array];</span><br><span class="line">return [helloWorld subscribeNext:^(NSString *x) &#123;</span><br><span class="line">[strings addObject:x];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendNext:[strings componentsJoinedByString:@&quot;&quot;]];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>现在我们有了一个joiner signal,当有订阅者订阅了joiner，它会定义我们的helloworld signal.</p>
<p>它从helloworld和helloword完成时候增加了所有数据的接收，它将所有接收到的string连接在一起，然后发送他们和完成</p>
<p>在这种方式，我们可以创建signal来表达一些复杂的行为。</p>
<p>RAC实现了一套<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/ead2c74fa619b30d161da36af9941af2ae123c5b/ReactiveCocoa/RACSignal%2BOperations.h" target="_blank" rel="noopener">operations</a>来恰好的实现他们，他们通过使用一些默认的行为来获取一些source signal 和返回一个新的signal</p>
<h2 id="More-info"><a href="#More-info" class="headerlink" title="More info"></a>More info</h2><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>可以用于MAC和iOS开发，可以查看<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md" target="_blank" rel="noopener">README</a>来获取更多的信息，然后来导出MAC demo project 来获得一些实际的例子</p>
<p>对于.NET 开发者，所有这些听起来会很熟悉， ReactiveCocoa实际上是一个Objective-c版本的.NET  <a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103" target="_blank" rel="noopener">Reactive Extensions</a>)(Rx).</p>
<p>大多数的Rx规则应用于RAC上是非常合适的，这里是一些非常好的Rx资源：</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103" target="_blank" rel="noopener">Reactive Extensions MSDN entry</a>)</li>
<li><a href="">Reactive Extensions for .NET Introduction</a></li>
<li><a href="https://channel9.msdn.com/tags/Rx/" target="_blank" rel="noopener">Rx – Channel 9 videos</a></li>
<li><a href="http://rxwiki.wikidot.com/" target="_blank" rel="noopener">Reactive Extensions wiki</a></li>
<li><a href="http://rxwiki.wikidot.com/101samples" target="_blank" rel="noopener">101 Rx Samples</a></li>
<li><a href="https://www.amazon.com/Programming-Reactive-Extensions-Jesse-Liberty/dp/1430237473" target="_blank" rel="noopener">Programming Reactive Extensions and LINQ</a> (Co-authored by our own <a href="https://github.com/paulcbetts" target="_blank" rel="noopener">Paul Betts</a>!)</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/03/12/pomera/">pomera</a><a class="next" href="/2019/02/25/fastlane/">fastlane</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'nu5iv8I7XfqMRqsPlXpcDKEe-gzGzoHsz',
  appKey:'iVSeGxiMcvCazRicwJuHKWts',
  placeholder:'请输入评论',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.cocoathinking.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/iOS9/" style="font-size: 15px;">iOS9</a> <a href="/tags/Search-API/" style="font-size: 15px;">Search API</a> <a href="/tags/NSUserActivity/" style="font-size: 15px;">NSUserActivity</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/weak-strong-dance/">weak-strong dance</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/block/">block</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/pomera/">pomera</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/翻译：ReactiveCocoa-for-a-better-world/">翻译：ReactiveCocoa for a better world</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/25/fastlane/">fastlane</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/2-常用操作和高阶函数/">Reactivecocoa全解析 2.常用操作和高阶函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/1-FRP编程思想/">Reactivecocoa全解析 1.FRP编程思想</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/博客重启/">cocoaThinking重启计划</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/25/NSUserActivity/">iOS9 Search API NSUserActivity</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/26/数组/">NSArray和NSMutableArray</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">刘渣渣的Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>