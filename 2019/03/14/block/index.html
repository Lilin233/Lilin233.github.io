<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="好奇 专注 保持进步"><title>block | 刘渣渣的Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">block</h1><a id="logo" href="/.">刘渣渣的Blog</a><p class="description">好奇 专注 保持进步</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Inicio</i></a><a href="/archives/"><i class="fa fa-archive"> Archivo</i></a><a href="/about/"><i class="fa fa-user"> Acerca de</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">block</h1><div class="post-meta">Mar 14, 2019</div><a class="disqus-comment-count" href="/2019/03/14/block/#vcomment"><span class="valine-comment-count" data-xid="/2019/03/14/block/"></span><span> Comment</span></a><div class="post-content"><p>说到Block，首先要介绍一下闭包（closure）,这是闭包在<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming" target="_blank" rel="noopener">wiki</a>)中的介绍：</p>
<blockquote>
<p>In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function[a] together with an environment.[1] The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.[b] Unlike a plain function, a closure allows the function to access those captured variables through the closure’s copies of their values or references, even when the function is invoked outside their scope.</p>
</blockquote>
<blockquote>
<p>闭包是一个函数或者是一个带有引用环境的函数，这个环境是一张存有这个函数中所有非本地变量的表</p>
</blockquote>
<p>各种编程语言对闭包都有着自己的实现，c#有lambda，js有Closures，C++有函数对象等，而block就是苹果在OS X Snow Leopard和iOS4中开始引入的对C语言的扩展，从此广大开发者在执行数据的回调时又有了多一个选项。而且相对繁琐的delegate，block更加的灵活轻便</p>
<p>接下来我会从几个部分来介绍block</p>
<ol>
<li>block的内部实现</li>
<li>block的分类<br>###block的内部实现<br>在<a href="https://llvm.org/svn/llvm-project/compiler-rt/tags/Apple/Libcompiler_rt-10/BlocksRuntime/Block_private.h" target="_blank" rel="noopener">LLVM Block_private.h</a>中可以找Block的定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* Revised new layout. */</span><br><span class="line">struct Block_descriptor &#123;</span><br><span class="line">unsigned long int reserved;</span><br><span class="line">unsigned long int size;</span><br><span class="line">void (*copy)(void *dst, void *src);</span><br><span class="line">void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">void *isa;</span><br><span class="line">int flags;</span><br><span class="line">int reserved; </span><br><span class="line">void (*invoke)(void *, ...);</span><br><span class="line">struct Block_descriptor *descriptor;</span><br><span class="line">/* Imported variables. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到Block存在着isa指针，我们知道所有实例对象的isa指针都指向了它的类对象，类对象的isa指向了原类对象。这也符合Apple对Block的描述，block也是一个对象，它可以像其他的对象一样存放在Array和Dictionary中</p>
<p>在上述结构体中，最重要的是invoke变量，从声明中可以看出，这是一个函数指针，指向了block的执行代码，block的执行代码就是一个匿名函数，在创建block的时候传递给了invoke变量</p>
<p>Block_layout结构体中包含了一个descriptor变量，而Block_descriptor比较重要的是copy和dispose函数，从字面上来看，copy用于捕获变量并且持有引用，dispose函数用于释放捕获的变量。block捕获的变量都会存放在结构体Block_layout的后面，对于对象存储的指针，在invoke函数执行之前全部读出。</p>
<h3 id="block的分类"><a href="#block的分类" class="headerlink" title="block的分类"></a>block的分类</h3><p>block根据内存分步可以分为三类：<br>NSGlobalBlock 全局的静态block，不会访问任何外部变量<br>NSStackBlock 保存在栈上的block，当函数返回时会被销毁<br>NSMallocBlock 保存在堆上的block，当引用计数为0时候会被销毁</p>
<p>你可以使用下边代码创建出这三种block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *age = @&quot;11&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;, ^&#123;&#125;);</span><br><span class="line">NSLog(@&quot;%@&quot;, ^&#123;NSLog(@&quot;%@&quot;, age);&#125;);</span><br><span class="line">void(^block)(void) = ^&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, age);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;, block);</span><br></pre></td></tr></table></figure></p>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-03-14 14:38:05.435150+0800 Block[5544:702103] &lt;__NSGlobalBlock__: 0x10f6ba180&gt;</span><br><span class="line">2019-03-14 14:38:05.435306+0800 Block[5544:702103] &lt;__NSStackBlock__: 0x7ffee05459f8&gt;</span><br><span class="line">2019-03-14 14:38:05.435437+0800 Block[5544:702103] &lt;__NSMallocBlock__: 0x60000270d5f0&gt;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看一下这三类block在内部实现上的差别</p>
<h4 id="NSGlobalBlock的内部实现"><a href="#NSGlobalBlock的内部实现" class="headerlink" title="NSGlobalBlock的内部实现"></a>NSGlobalBlock的内部实现</h4><p>这里我们要使用clang命令将Objective-C代码转换成C语言来查看block的源码具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc block.m</span><br></pre></td></tr></table></figure></p>
<p>创建一个GlobalBlock.m文件，打印一个空的blog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;, ^&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行clang -rewrite-objc命令后，在目录下会多一个GlobalBlock.cpp文件，我们去除一些无用的代码，关键代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct __GlobalBlock__testBlock_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __GlobalBlock__testBlock_block_desc_0* Desc;</span><br><span class="line">__GlobalBlock__testBlock_block_impl_0(void *fp, struct __GlobalBlock__testBlock_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __GlobalBlock__testBlock_block_func_0(struct __GlobalBlock__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">&#125;</span><br><span class="line">static struct __GlobalBlock__testBlock_block_desc_0 &#123;</span><br><span class="line">size_t reserved;</span><br><span class="line">size_t Block_size;</span><br><span class="line">&#125; __GlobalBlock__testBlock_block_desc_0_DATA = &#123; 0, sizeof(struct __GlobalBlock__testBlock_block_impl_0)&#125;;</span><br><span class="line">static void _I_GlobalBlock_testBlock(GlobalBlock * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_GlobalBlock_2850c5_mi_0, ((void (*)())&amp;__GlobalBlock__testBlock_block_impl_0((void *)__GlobalBlock__testBlock_block_func_0, &amp;__GlobalBlock__testBlock_block_desc_0_DATA)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法 <strong>GlobalBlock</strong>testBlock_block_impl_0就是block的实现，我们可以看到 isa指向了 _NSConcreteStackBlock，这里的impl指向了<strong>main_block_func_0， </strong>main_block_func_0就是创建block时定义的一个函数。因为我们创建的block是空的，所以这里__main_block_func_0也是空的</p>
<h4 id="NSStackBlock的内部实现"><a href="#NSStackBlock的内部实现" class="headerlink" title="NSStackBlock的内部实现"></a>NSStackBlock的内部实现</h4><p>创建一个StackBlock.m，添加上以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *age = @&quot;11&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;, ^&#123;NSLog(@&quot;%@&quot;, age);&#125;);</span><br></pre></td></tr></table></figure></p>
<p>clang后获取关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct __StackGlobal__testBlock_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __StackGlobal__testBlock_block_desc_0* Desc;</span><br><span class="line">NSString *age;</span><br><span class="line">__StackGlobal__testBlock_block_impl_0(void *fp, struct __StackGlobal__testBlock_block_desc_0 *desc, NSString *_age, int flags=0) : age(_age) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __StackGlobal__testBlock_block_func_0(struct __StackGlobal__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">NSString *age = __cself-&gt;age; // bound by copy</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_StackGlobal_291f7c_mi_2, age);&#125;</span><br><span class="line">static void __StackGlobal__testBlock_block_copy_0(struct __StackGlobal__testBlock_block_impl_0*dst, struct __StackGlobal__testBlock_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;age, (void*)src-&gt;age, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line">static void __StackGlobal__testBlock_block_dispose_0(struct __StackGlobal__testBlock_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;age, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line">static struct __StackGlobal__testBlock_block_desc_0 &#123;</span><br><span class="line">size_t reserved;</span><br><span class="line">size_t Block_size;</span><br><span class="line">void (*copy)(struct __StackGlobal__testBlock_block_impl_0*, struct __StackGlobal__testBlock_block_impl_0*);</span><br><span class="line">void (*dispose)(struct __StackGlobal__testBlock_block_impl_0*);</span><br><span class="line">&#125; __StackGlobal__testBlock_block_desc_0_DATA = &#123; 0, sizeof(struct __StackGlobal__testBlock_block_impl_0), __StackGlobal__testBlock_block_copy_0, __StackGlobal__testBlock_block_dispose_0&#125;;</span><br><span class="line">static void _I_StackGlobal_testBlock(StackGlobal * self, SEL _cmd) &#123;</span><br><span class="line">NSString *age = (NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_StackGlobal_291f7c_mi_0;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_StackGlobal_291f7c_mi_1, ((void (*)())&amp;__StackGlobal__testBlock_block_impl_0((void *)__StackGlobal__testBlock_block_func_0, &amp;__StackGlobal__testBlock_block_desc_0_DATA, age, 570425344)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们看到impl.isa指向了_NSConcreteStackBlock，<strong>StackGlobal</strong>testBlock_block_impl_0中增加了一个变量age，在block中引用的age实际上在申明block时就被就被复制到了<strong>StackGlobal</strong>testBlock_block_impl_0结构体中的变量age，心在我们就能够理解，在block内部修改变量age的内容，不会影响外部的实际变量age</p>
<p>在使用block时想要在block内部修改局部变量，需要使用__block来修饰局部变量，此时block的内部实现是怎样的呢<br>修改StackBlock.h中代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *age = @&quot;11&quot;;</span><br><span class="line">__block NSInteger index = 1;</span><br><span class="line">^&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, age);</span><br><span class="line">index = 2;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<p>重新执行clang,源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_index_0 &#123;</span><br><span class="line">void *__isa;</span><br><span class="line">__Block_byref_index_0 *__forwarding;</span><br><span class="line">int __flags;</span><br><span class="line">int __size;</span><br><span class="line">NSInteger index;</span><br><span class="line">&#125;;</span><br><span class="line">struct __StackGlobal__testBlock_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __StackGlobal__testBlock_block_desc_0* Desc;</span><br><span class="line">NSString *age;</span><br><span class="line">__Block_byref_index_0 *index; // by ref</span><br><span class="line">__StackGlobal__testBlock_block_impl_0(void *fp, struct __StackGlobal__testBlock_block_desc_0 *desc, NSString *_age, __Block_byref_index_0 *_index, int flags=0) : age(_age), index(_index-&gt;__forwarding) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __StackGlobal__testBlock_block_func_0(struct __StackGlobal__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">__Block_byref_index_0 *index = __cself-&gt;index; // bound by ref</span><br><span class="line">NSString *age = __cself-&gt;age; // bound by copy</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_StackGlobal_274897_mi_1, age);</span><br><span class="line">(index-&gt;__forwarding-&gt;index) = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到多了一个<strong>Block_byref_index_0结构体，其中包含一个index变量， </strong>StackGlobal__testBlock_block_func_0中多了一个__Block_byref_index_0的指针，这样就可以完成修改外部变量</p>
<p>NSMallocBlock的内部实现<br>NSMallocBlock类型的block在源码中无法体现出来，因为NSMallocBlock是在stackblock在执行copy后才会被拷贝到malloc上，我们可以看一下<a href="https://opensource.apple.com/source/clang/clang-137/src/projects/compiler-rt/BlocksRuntime/runtime.c" target="_blank" rel="noopener">runtime.c</a>的源码，在这里可以看到block是如何从stack拷贝到malloc的<br>重点看一下_Block_copy_internal函数中这一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Its a stack block.  Make a copy.</span><br><span class="line">if (!isGC) &#123;</span><br><span class="line">struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">if (!result) return (void *)0;</span><br><span class="line">memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first</span><br><span class="line">// reset refcount</span><br><span class="line">result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed</span><br><span class="line">result-&gt;flags |= BLOCK_NEEDS_FREE | 1;</span><br><span class="line">result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">//printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span><br><span class="line">(*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果判断block位于stack中，则执行copy方法<br>可以看到在这里讲isa指向了_NSConcreteMallocBlock。此时，位于stack上的block就被转成了NSMallocBlock类型的block</p>
<p>我们可以看到，苹果的网络请求API NSURLConnect还是用的delegate来实现回调，而到了NSURlSession，苹果更多的是换成了Block，更不要说RAC中遍布所有API中的block，所以只有你对Block有着足够深刻的理解，在使用这些框架时候才能更加的游刃有余，做到知其然知其所以然。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/03/14/weak-strong-dance/">weak-strong dance</a><a class="next" href="/2019/03/12/pomera/">pomera</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'nu5iv8I7XfqMRqsPlXpcDKEe-gzGzoHsz',
  appKey:'iVSeGxiMcvCazRicwJuHKWts',
  placeholder:'请输入评论',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.cocoathinking.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categorías</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Etiquetas</i></div><div class="tagcloud"><a href="/tags/iOS9/" style="font-size: 15px;">iOS9</a> <a href="/tags/Search-API/" style="font-size: 15px;">Search API</a> <a href="/tags/NSUserActivity/" style="font-size: 15px;">NSUserActivity</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recientes</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/04/iOS多线程 --- pthread和NSThread/">iOS多线程 --- pthread和NSThread</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/栈的最佳实践-打造一个逆波兰计算器/">栈的最佳实践 - 打造一个逆波兰计算器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/22/iOS中Active与JS的交互/">iOS中Active与JS的交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/weak-strong-dance/">weak-strong dance</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/14/block/">block</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/pomera/">pomera</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/翻译：ReactiveCocoa-for-a-better-world/">翻译：ReactiveCocoa for a better world</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/25/fastlane/">fastlane</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/2-常用操作和高阶函数/">Reactivecocoa全解析 2.常用操作和高阶函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/1-FRP编程思想/">Reactivecocoa全解析 1.FRP编程思想</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://dulingkang.github.io" title="shawnDu" target="_blank">shawnDu</a><ul></ul><a href="www.wendao.info" title="张省三" target="_blank">张省三</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">刘渣渣的Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>