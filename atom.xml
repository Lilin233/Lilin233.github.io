<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘渣渣的Blog</title>
  
  <subtitle>好奇 专注 保持进步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.cocoathinking.com/"/>
  <updated>2019-02-01T08:42:28.429Z</updated>
  <id>https://www.cocoathinking.com/</id>
  
  <author>
    <name>刘渣渣</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cocoaThinking重启计划</title>
    <link href="https://www.cocoathinking.com/2019/02/01/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF/"/>
    <id>https://www.cocoathinking.com/2019/02/01/博客重启/</id>
    <published>2019-02-01T08:37:17.000Z</published>
    <updated>2019-02-01T08:42:28.429Z</updated>
    
    <content type="html"><![CDATA[<p>我在2015年开通了自己的博客，博客通过hexo+github搭建，博客开通的虽早，但是写作确没有怎么坚持下来，2015年到现在零零散散的写了不到10篇，多数还是在15年趁着刚刚搭建完的热乎劲写成，实在汗颜。2019阴历新年马上就要到了，我决定制定一个cocoaThinking重启计划，一方面写一写技术总结，另一方面也有地方可以写一下日常的生活点滴。<br>这次博客的重启，我更新了一些必要工具，hexo，node，npm，还有hexo的模板Next，更新的时候我发现node的版本从当时的0.10升级到了11.15，hexo和next也都完成多个版本的升级，不得不感慨时光匆匆，几年的时间过的真快，当时搭建博客的时候和我的同事showndu一起研究讨论问题的场景还是历历在目，这也更坚定了我对这次重启计划的决心。<br>看了一下自己以前写的文章，多数因为年代久远已经过时了，剩下的几篇比如《iOS常用设计模式》，因为当时的自己较为年轻，写的文章也有很多不足。所以会对之前的文章进行清理，过时的删掉，不足的会进行修改补充。接下来先完成这部分工作吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我在2015年开通了自己的博客，博客通过hexo+github搭建，博客开通的虽早，但是写作确没有怎么坚持下来，2015年到现在零零散散的写了不到10篇，多数还是在15年趁着刚刚搭建完的热乎劲写成，实在汗颜。2019阴历新年马上就要到了，我决定制定一个cocoaThinki
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS9 Search API NSUserActivity</title>
    <link href="https://www.cocoathinking.com/2015/09/25/NSUserActivity/"/>
    <id>https://www.cocoathinking.com/2015/09/25/NSUserActivity/</id>
    <published>2015-09-25T03:33:47.000Z</published>
    <updated>2015-09-25T03:49:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在WWDC2015会议上，苹果公布了iOS9系统，iOS9系统相比iOS7、iOS8并没有特别大得变化，可以看做是iOS8的基础上进行的平滑的过度。但是新的系统中仍有一些特性和功能值得人们去关注，其中<br>Search API就是其中之一。通过新的Search API可以实现强大的应用内搜索功能，通过在Spotlight中使用我们设计的所以，来查看app中的界面或是内容。</p><h4 id="iOS9的-Search-API由三个组件组成："><a href="#iOS9的-Search-API由三个组件组成：" class="headerlink" title="iOS9的 Search API由三个组件组成："></a>iOS9的 Search API由三个组件组成：</h4><p>1.NSUserActivity<br>2.Web Markup<br>3.Core Spotlight<br>现在介绍一下NSUserActivity的使用<br>NSUserActivity是在iOS8中出现的API，主要用户HandOff功能，iOS9中NSUserActivity新增加了一个属性 eligibleForSearch 来控制在Spotlight中的显示<br><a id="more"></a></p><p>定义一个NSUserActivity属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong)NSUserActivity *activity;</span><br></pre></td></tr></table></figure></p><p>初始化NSUserActivity,并设置属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//ActivityType为唯一标识</span><br><span class="line">_activity = [[NSUserActivity alloc]initWithActivityType:@&quot;Eden&quot;];</span><br><span class="line"></span><br><span class="line">//title app在Spotlight中显示的名称，可以和app名称不一样，多个app使用相同的keywords，初始通过title名称进行排序</span><br><span class="line">_activity.title = @&quot;Eden&quot;;</span><br><span class="line"></span><br><span class="line">//Spolight搜索关键字</span><br><span class="line">_activity.keywords = [NSSet setWithArray:@[@&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Eve&quot;]];</span><br><span class="line"></span><br><span class="line">//关闭HandOff功能</span><br><span class="line">_activity.eligibleForHandoff = NO;</span><br><span class="line"></span><br><span class="line">//开启Spotlight search功能</span><br><span class="line">_activity.eligibleForSearch = YES;</span><br><span class="line"></span><br><span class="line">//开启NSUserActivity</span><br><span class="line">[_activity becomeCurrent];</span><br></pre></td></tr></table></figure></p><p>当做完这些操作时候然后运行程序，我们在spotlight中搜索 adam, lilith, eva中的某一个关键字就会找到我们的应用，此时选择应用会直接跳转到app的首页。有时候我们希望最好能通过某个关键字直接跳转到app其中某一页，幸运的是NSUserActivity同样支持这个功能。</p><h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h4><p>创建AdmaViewController，LilithViewController<br>我们在AdmaViewController中创建adamUserActivity,title为adamView, 关键字adam<br>我们在LilithViewController中创建lilithUserActivity, title为lilithView,关键字lilith<br>可以在首页通过adam跳转到admaViewController<br>可以在首页通过lilith跳转到lilithViewController</p><h4 id="开始工作："><a href="#开始工作：" class="headerlink" title="开始工作："></a>开始工作：</h4><p>找到AppDelegate文件，添加方法</p><p>//在主线程下存在可用NSUserActivity对象时候调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123;</span><br><span class="line"></span><br><span class="line">//找到当前的window的rootView转换为UINavigationController(如果你的rootView是UINavigationController的话)</span><br><span class="line">    UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;</span><br><span class="line"></span><br><span class="line">//找到navigationController的topView（首页） 中restoreUserActivityState方法</span><br><span class="line">    [navigationController.topViewController restoreUserActivityState:userActivity];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 在首页中重写restoreUserActivityState方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)restoreUserActivityState:(NSUserActivity *)activity&#123;</span><br><span class="line">//通过Spotlight中传过来的NSUserActivity对象的title判断具体跳转到哪一页</span><br><span class="line">    if ([activity.title isEqualToString:@&quot;Adam&quot;]) &#123;</span><br><span class="line">        AdamViewController *adamView = [[AdamViewController alloc]init];</span><br><span class="line">        [self.navigationController pushViewController:adamView animated:YES];</span><br><span class="line">    &#125;else if([activity.title isEqualToString:@&quot;Lilith&quot;])&#123;</span><br><span class="line">        LilithViewController *lilithView = [[LilithViewController alloc]init];</span><br><span class="line">        [self.navigationController pushViewController:lilithView animated:YES];</span><br><span class="line">    &#125;else  if([activity.title isEqualToString:@&quot;Eve&quot;])&#123;</span><br><span class="line">        EveViewController *eveView = [[EveViewController alloc]init];</span><br><span class="line">        [self.navigationController pushViewController:eveView animated:YES];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当选择再Spotlight中搜索adam，选择应用会直接跳转到 adamViewController中，搜索lilith关键字，选择应用会直接跳转到lilithViewController中</p><p><a href="https://github.com/Lilin233/iOS9NSUserActivity" target="_blank" rel="noopener">本文代码下载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在WWDC2015会议上，苹果公布了iOS9系统，iOS9系统相比iOS7、iOS8并没有特别大得变化，可以看做是iOS8的基础上进行的平滑的过度。但是新的系统中仍有一些特性和功能值得人们去关注，其中&lt;br&gt;Search API就是其中之一。通过新的Search API可以实现强大的应用内搜索功能，通过在Spotlight中使用我们设计的所以，来查看app中的界面或是内容。&lt;/p&gt;
&lt;h4 id=&quot;iOS9的-Search-API由三个组件组成：&quot;&gt;&lt;a href=&quot;#iOS9的-Search-API由三个组件组成：&quot; class=&quot;headerlink&quot; title=&quot;iOS9的 Search API由三个组件组成：&quot;&gt;&lt;/a&gt;iOS9的 Search API由三个组件组成：&lt;/h4&gt;&lt;p&gt;1.NSUserActivity&lt;br&gt;2.Web Markup&lt;br&gt;3.Core Spotlight&lt;br&gt;现在介绍一下NSUserActivity的使用&lt;br&gt;NSUserActivity是在iOS8中出现的API，主要用户HandOff功能，iOS9中NSUserActivity新增加了一个属性 eligibleForSearch 来控制在Spotlight中的显示&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://www.cocoathinking.com/categories/iOS/"/>
    
    
      <category term="iOS9" scheme="https://www.cocoathinking.com/tags/iOS9/"/>
    
      <category term="Search API" scheme="https://www.cocoathinking.com/tags/Search-API/"/>
    
      <category term="NSUserActivity" scheme="https://www.cocoathinking.com/tags/NSUserActivity/"/>
    
  </entry>
  
  <entry>
    <title>NSArray和NSMutableArray</title>
    <link href="https://www.cocoathinking.com/2015/08/26/%E6%95%B0%E7%BB%84/"/>
    <id>https://www.cocoathinking.com/2015/08/26/数组/</id>
    <published>2015-08-26T14:09:39.000Z</published>
    <updated>2015-08-26T14:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组作为存储对象的有序集合，可能是平时用到的最多的集合类。NS数组中存放的是Fundation对象，简单类型比如int，float等可以封装为NSNumber对象来存放到数组中。<br>Objc中数组分为不可变数组和可变数组，可变数组使用NSMutableArray来处理，不可变数组为NSArray，NSMutableArray是NSArray的子类，也就是说继承了NSArray得所有方法</p><h3 id="1-创建一个数组"><a href="#1-创建一个数组" class="headerlink" title="1.创建一个数组"></a>1.创建一个数组</h3><p>创建一个NSArray<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = [NSArray arrayWithObjects:@1, @2, @3, nil];</span><br><span class="line"></span><br><span class="line">NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:10];</span><br><span class="line"></span><br><span class="line">NSMutableArray *array2 = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:0];</span><br></pre></td></tr></table></figure></p><blockquote><p>使用initWithCapacity方法可以在初始化数组的时候添加一个预留空间，在数组空间超过这个预留空间时候会进行自动追加。不过是再测试中发现这样做并没有提高应有的效率，传言苹果实际上没有采用这个参数。不过这样有个好处是可以做为一个隐性文档来提高代码可读性。<br><a id="more"></a></p></blockquote><p>在创建NSArray数组的时候也可以使用语法糖，相对于调用方法更加简单快捷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];</span><br></pre></td></tr></table></figure></p><h3 id="2-NSArray-和NSMutableArray-转换"><a href="#2-NSArray-和NSMutableArray-转换" class="headerlink" title="2.NSArray 和NSMutableArray 转换"></a>2.NSArray 和NSMutableArray 转换</h3><p>//NSMutableArray 转换NSArray<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建可变数组</span><br><span class="line">NSMutableArray *mutableArray = [NSMutableArray array];</span><br><span class="line">// 使用copy方法获得一个NSArray。使用三木运算符判断当NSArray为nil时候重新初始化一个新的对象</span><br><span class="line">// x?:y == x?x:y;  </span><br><span class="line">NSArray *array = [mutableArray copy]?:[NSArray array];</span><br></pre></td></tr></table></figure></p><p>//NSArray 转换NSMutableArray<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化一个NSArray</span><br><span class="line">NSArray *array = @[@7, @2 ,@0 ,@1, @6, @8, @3] ;</span><br><span class="line">// 使用mutableCopy方法获得一个NSMutableArray</span><br><span class="line">NSMutableArray *mutableArray = [array mutableCopy]?:[NSMutableArray array];</span><br><span class="line">//使用类方法arrayWithArray进行转换</span><br><span class="line">NSMutableArray *mutableArray2 = [NSMutableArray arrayWithArray:array];</span><br></pre></td></tr></table></figure></p><h3 id="3-查找对象"><a href="#3-查找对象" class="headerlink" title="3.查找对象"></a>3.查找对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id object  = [array objectAtIndex:index];</span><br></pre></td></tr></table></figure><p>同样可以通过语法糖获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id object = array[index];</span><br></pre></td></tr></table></figure></p><p>NSArray提供firstObject, lastObject,方法获取数组的首尾对象，当数组为空时候返回nil。而使用常规方法获取空数组中的对象则会返回NSRangeException异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id lastObject  = [array lastObject];</span><br><span class="line">id firstObject = [array firstObject];</span><br></pre></td></tr></table></figure></p><p>为了方便数组中数据量很大的情况下查找数据，苹果已经预先实现二分查找法来遍历数组，这样查询效率将大大提高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];</span><br><span class="line">NSMutableArray *mutableArray = [NSMutableArray array];</span><br><span class="line">NSRange range = NSMakeRange(0, 5);</span><br><span class="line">NSInteger index = [array indexOfObject:@0 inSortedRange:range options:NSBinarySearchingInsertionIndex usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">    if (obj1 &lt; obj2) &#123;</span><br><span class="line">        return NSOrderedAscending;</span><br><span class="line">    &#125;</span><br><span class="line">        return NSOrderedDescending;</span><br><span class="line">&#125;];</span><br><span class="line">id object = mutableArray[index];</span><br></pre></td></tr></table></figure></p><h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4.排序"></a>4.排序</h3><p>有很多方法可以对数组进行排序，如果数组中存放的是字符串对象，可以使用sortedArrayUsingSelector:方法进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;];</span><br><span class="line">NSArray *newArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];</span><br></pre></td></tr></table></figure></p><p>如果数组存放的是数字，可以使用compare:方法进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@4, @0, @8, @9, @11];</span><br><span class="line">NSArray *newArray = [array sortedArrayUsingSelector:@selector(compare:)];</span><br></pre></td></tr></table></figure></p><p>可是使用reverseObjectEnumerator.allObjects获得一个数组的逆序排列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@4, @0, @8, @9, @11];</span><br><span class="line">NSArray *newArray = array.reverseObjectEnumerator.allObjects;</span><br></pre></td></tr></table></figure></p><h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><p>从一个数组过滤一些元素，组成另一个数组使我们经常遇到的一个场景，同样Objc提供了很多方法可以实现<br>1.快速枚举 NSFastEnumeration(for in)<br>使用快速枚举在数组数据量较大的情况下效率会比传统的for循环提高很多，而且快速枚举代码的可读性也更高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];</span><br><span class="line">NSMutableArray *newArray = [NSMutableArray array];</span><br><span class="line">for (NSString *godName in array) &#123;</span><br><span class="line">    if ([godName containsString:@&quot;l&quot;]) &#123;                        [newArray addObject:godName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">NSLog(@&quot;%@&quot;,newArray);</span><br></pre></td></tr></table></figure></p><p>2.使用indexesOfObjectsWithOptions方法<br>当数据量很大的情况下，使用indexesOfObjectsWithOptions方法的NSEnumerationConcurrent参数可以开启同步执行，但这也只是在数据量很大的情况下，当数据量较少时候因为需要额外的线程管理效率会变得更低一些<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];</span><br><span class="line">NSIndexSet *indexSet = [array indexesOfObjectsWithOptions:NSEnumerationConcurrent passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    if ([obj isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">        NSString *godName = obj;</span><br><span class="line">        if ([godName containsString:@&quot;l&quot;]) &#123;</span><br><span class="line">                    return obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">NSArray *newArray = [array objectsAtIndexes:indexSet];</span><br><span class="line">NSLog(@&quot;%@&quot;,newArray);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组作为存储对象的有序集合，可能是平时用到的最多的集合类。NS数组中存放的是Fundation对象，简单类型比如int，float等可以封装为NSNumber对象来存放到数组中。&lt;br&gt;Objc中数组分为不可变数组和可变数组，可变数组使用NSMutableArray来处理，不可变数组为NSArray，NSMutableArray是NSArray的子类，也就是说继承了NSArray得所有方法&lt;/p&gt;
&lt;h3 id=&quot;1-创建一个数组&quot;&gt;&lt;a href=&quot;#1-创建一个数组&quot; class=&quot;headerlink&quot; title=&quot;1.创建一个数组&quot;&gt;&lt;/a&gt;1.创建一个数组&lt;/h3&gt;&lt;p&gt;创建一个NSArray&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray *array = [NSArray arrayWithObjects:@1, @2, @3, nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:10];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *array2 = [NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用initWithCapacity方法可以在初始化数组的时候添加一个预留空间，在数组空间超过这个预留空间时候会进行自动追加。不过是再测试中发现这样做并没有提高应有的效率，传言苹果实际上没有采用这个参数。不过这样有个好处是可以做为一个隐性文档来提高代码可读性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS常用设计模式</title>
    <link href="https://www.cocoathinking.com/2015/08/12/iOS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.cocoathinking.com/2015/08/12/iOS常用设计模式/</id>
    <published>2015-08-12T09:04:17.000Z</published>
    <updated>2015-08-12T09:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>所有的iPhone应用程序都是基于UIKit框架构建而成的，所以它们在本质上具有相同的核心架构。</p><blockquote><p>UIKit框架的设计模式 结合了很多在Mac OS X Cocoa应用程序中使用的设计模式，理解这些设计模式对于创建iPhone程序是很关键的。</p></blockquote><h3 id="1-模型-视图-控制器模式-MVC模式"><a href="#1-模型-视图-控制器模式-MVC模式" class="headerlink" title="1.模型-视图-控制器模式 MVC模式"></a>1.模型-视图-控制器模式 MVC模式</h3><p>模型-视图-控制器模式(model-view-controller)简称MVC模式，它将您的代码独立分割为几个部分。模型部分定义应用程序的数据引擎，负责维护数据的完整性；视图定义应用程序的用户界面；控制器则充当模型和视图的桥梁，负责实现数据和现实的更新。<br><a id="more"></a></p><h3 id="2-目标-动作"><a href="#2-目标-动作" class="headerlink" title="2.目标-动作"></a>2.目标-动作</h3><p>控件通过目标-动作的模式将用户的交互通知您的应用程序，当用户以预先定义好的动作（比如点击一个按钮）进行交互时，空间就会将消息（动作）发送给您制定的对象（目标）。接收到动作消息后，目标对象就会以恰当的方式相应（比如按动按钮的时候刷新应用程序的状态）。</p><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><p>单例模式确保一个给定类只有一个实例出现，这个实例有一个全局的访问点，它通常使用懒加载的时候在第一次使用的时候再取加载<br>注意：苹果使用了大量的单例模式，我们用到的[UIAppliacation shareapplication],[UIScreen mainscreen],[NSUserDefaults standardUserDefaults] 等返回的都是一个单例对象。<br>在一些情况下使用单例模式会是非常合理的，比如你需要一个全局配置处理类，使用单例模式就会很好的实现。<br>使用GCD的方式可以很容易实现一个单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+(Singelton)shareInstance&#123;</span><br><span class="line"> // 1</span><br><span class="line"> static Singelton *st;</span><br><span class="line"> // 2</span><br><span class="line"> static dispatch_once_t onceToken;</span><br><span class="line"> // 3</span><br><span class="line"> dispatch_once(&amp;onceToken,^&#123;</span><br><span class="line"> st =[[Singelton alloc]init];</span><br><span class="line"> &#125;);</span><br><span class="line"> return st;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中有三个需要注意的地方：</p><ol><li>声明一个static静态变量保存实例变量，确保它在类中的全局可用性。</li><li>声明一个static静态dispath_once_t，确保初始化代码只执行一次</li><li>使用 Grand Center Dispatch (GCD)执行Singelton变量block，正式单例模式的关键，一旦类被初始化，初始化器就不会再被调用<br>下次再调用shareInstance的时候，dispatch_once块中得代码将不会执行（因为他已经被执行了一次），你将得到已经初始化好的类</li></ol><h3 id="4-代理设计模式"><a href="#4-代理设计模式" class="headerlink" title="4.代理设计模式"></a>4.代理设计模式</h3><p>代理设计模式  一个对象提供机会对另一个对象发生变化时候做出反应。<br>代理模式基本思想：两个对象协同解决问题，通常用于对象之间的通信</p><p>Cocoa 框架中同样运用了大量的代理模式，每个UI控件后边都声明了一个id类型的delegate或是datasource，比如说最常用到的UITableView 控件头文件中声明了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (notamatic, assign)id &lt;UITableViewDataSource&gt; datasource;  </span><br><span class="line">@property (notamatic, assign)id &lt;UITableViewDelegate&gt; delegate;</span><br></pre></td></tr></table></figure></p><p>即这个代理要遵循某一个协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有的iPhone应用程序都是基于UIKit框架构建而成的，所以它们在本质上具有相同的核心架构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UIKit框架的设计模式 结合了很多在Mac OS X Cocoa应用程序中使用的设计模式，理解这些设计模式对于创建iPhone程序是很关键的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-模型-视图-控制器模式-MVC模式&quot;&gt;&lt;a href=&quot;#1-模型-视图-控制器模式-MVC模式&quot; class=&quot;headerlink&quot; title=&quot;1.模型-视图-控制器模式 MVC模式&quot;&gt;&lt;/a&gt;1.模型-视图-控制器模式 MVC模式&lt;/h3&gt;&lt;p&gt;模型-视图-控制器模式(model-view-controller)简称MVC模式，它将您的代码独立分割为几个部分。模型部分定义应用程序的数据引擎，负责维护数据的完整性；视图定义应用程序的用户界面；控制器则充当模型和视图的桥梁，负责实现数据和现实的更新。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
