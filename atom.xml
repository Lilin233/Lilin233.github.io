<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘渣渣的Blog</title>
  
  <subtitle>好奇 专注 保持进步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.cocoathinking.com/"/>
  <updated>2019-03-02T07:44:48.130Z</updated>
  <id>https://www.cocoathinking.com/</id>
  
  <author>
    <name>刘渣渣</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>翻译：ReactiveCocoa for a better world</title>
    <link href="https://www.cocoathinking.com/2019/03/02/%E7%BF%BB%E8%AF%91%EF%BC%9AReactiveCocoa-for-a-better-world/"/>
    <id>https://www.cocoathinking.com/2019/03/02/翻译：ReactiveCocoa-for-a-better-world/</id>
    <published>2019-03-02T07:43:06.000Z</published>
    <updated>2019-03-02T07:44:48.130Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ReactiveCocoa创造更美好的世界</strong><br><strong>原文：<a href="https://github.blog/2012-05-04-reactivecocoa-for-a-better-world/#async" target="_blank" rel="noopener">ReactiveCocoa for a better world</a></strong></p><blockquote><p>首先说一下为什么要翻译这篇2012年的文章。ReactiveCocoa for a better world是由<a href="https://github.blog/author/joshaber/" target="_blank" rel="noopener">Josh Abernathy</a>在2012年发表，那个时间刚好是ReactiveCocoa开源的时间，而作者<a href="https://github.blog/author/joshaber/" target="_blank" rel="noopener">Josh Abernathy</a>正是这一开源框架的主要作者，在这篇文章中Josh Abernathy从多个角度为我们介绍了为什么要使用ReactiveCocoa以及ReactiveCocoa能为我们做什么，在这篇文章中你可能会看到一些其他介绍ReactiveCocoa文章的影子，或者更应该说是在一些其他的关于ReactiveCocoa文章中看到ReactiveCocoa for a better world的影子。因为它的影响太深了，在时隔多年重新看到它后我有了把它翻译成中文的想法。</p></blockquote><p>原生App花费了大量的时间来等待和响应，我们等待用户在UI界面上做一些操作，等待网络请求返回响应，等待异步操作的完成，等待一些依赖数据发生改变，然后做出响应。</p><p>但是所有的这些事情-所有的这些等待和响应-通常都会有许多不同的处理方式，这让我们在使用统一的方法来推断他们，chain them，或者是完成它们来变得非常困难。其实，我们可以通过高级方法来做的更好。</p><p>这就为什么我们开源这个神奇的魔法：<a href="https://desktop.github.com/" target="_blank" rel="noopener"> GitHub for Mac: </a> :<a href="https://github.com/ReactiveCocoa/ReactiveCocoaRAC" target="_blank" rel="noopener">ReactiveCocoa</a></p><p>RAC是一个<strong>组合和转换序列值得框架。</strong></p><h2 id="认真讲，他是什么？"><a href="#认真讲，他是什么？" class="headerlink" title="##认真讲，他是什么？"></a>##认真讲，他是什么？</h2><p>让我们来看一些干货，RAC给我们带来了很多非常酷的东西：</p><ol><li>组合操作一些未来数据的能力</li><li>最小化的使用状态量和可变数据的能力</li><li>用一种方式定义行为和属性之间的联系</li><li>一个统一的，更高级的异步操作接口</li><li>在KVO之上封装的友好的API</li></ol><p>这些功能看起来可能像是随机的，直到你了解到RAC可以处理这些包含了将要等待的一些新值和响应的所有事件。</p><p>最美妙的地方在于RAC是那个能够适应许多不同的，常见的场景。<br>说了这么多，让我们来看看RAC实际上的样子</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="##Examples"></a>##Examples</h2><p>RAC可以将遵循了<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html" target="_blank" rel="noopener">KVO-compliant</a>属性利用<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="noopener">KVO(key-value observing)</a>l来带来序列的值.举个例子，我们可以看到username属性的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RACAble(self.username) subscribeNext:^(NSString *newName) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, newName);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>That’s cool,但是如果只有这些，那它只是一个比KOV更友好的API，RAC最酷的地方在于我们可以组合序列来一表示一些复杂的行为。<br>假设我们想要检查用户输入的一个特殊用户名，当用用户输入前三个值之内的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[[RACAble(self.username)</span><br><span class="line">distinctUntilChanged]</span><br><span class="line">take:3]</span><br><span class="line">filter:^(NSString *newUsername) &#123;</span><br><span class="line">return [newUsername isEqualToString:@&quot;joshaber&quot;];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeNext:^(id _) &#123;</span><br><span class="line">NSLog(@&quot;Hi me!&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>我们发现username发生了变化，使用filter过滤发生的变化，使用take取前三个发生变化的值，如果新值是joshaber,我们就打印一个“hi mi</p><h2 id="所以呢？"><a href="#所以呢？" class="headerlink" title="###所以呢？"></a>###所以呢？</h2><p>考虑一下，如果我们不使用RAC来完成这个操作，我们将不得不：</p><ul><li>为username添加上KVO进行监听</li><li>添加一个属性来记住我们通过KVO监听到的发生变化的最后一个值</li><li>添加一个属性来记录我们接收到了多少个发生了变化的值</li><li>任何时间获取到发生变化的值得时候都要添加属性</li><li>对数据进行比较</li></ul><p>###还有其他的么？</p><p>我们可以组合序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal</span><br><span class="line">combineLatest:@[ RACAble(self.password), RACAble(self.passwordConfirmation) ]</span><br><span class="line">reduce:^(NSString *currentPassword, NSString *currentConfirmPassword) &#123;</span><br><span class="line">return [NSNumber numberWithBool:[currentConfirmPassword isEqualToString:currentPassword]];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeNext:^(NSNumber *passwordsMatch) &#123;</span><br><span class="line">self.createEnabled = [passwordsMatch boolValue];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>当任何时间password和passwordConfirmation发生变化的时候，我们组合这两个属性最后的值，然后判断这两个值是否符合我们的要求，最后返回一个BOOL。我们就可以通过这个BOOL结果来设置button是否可以点击</p><p>###Bindings<br>We can adapt RAC to give us powerful bindings with conditions and transformations:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RAC(self, help) = [[RACObserve(self.helpLabel, text) filter:^(NSString *newHelp)&#123;</span><br><span class="line">return newHelp != nil;</span><br><span class="line">&#125;] map:^(NSString *newHelp)&#123;</span><br><span class="line">return [newHelp uppercaseString];</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>绑定help label的值得到属性help上，当流出的新值不是nil，就将这个新值转换成小写。（因为用户总喜欢being YELLED AT）、</p><p>###Async<br>RAC同样非常适合做异步操作</p><p>举个例子，我们通过调用一个block来完成多次并发操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal</span><br><span class="line">merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]]</span><br><span class="line">subscribeCompleted:^&#123;</span><br><span class="line">NSLog(@&quot;They&apos;re both done!&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>或是链式调用异步操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[[[client</span><br><span class="line">loginUser]</span><br><span class="line">flattenMap:^(id _) &#123;</span><br><span class="line">return [client loadCachedMessages];</span><br><span class="line">&#125;]</span><br><span class="line">flattenMap:^(id _) &#123;</span><br><span class="line">return [client fetchMessages];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeCompleted:^&#123;</span><br><span class="line">NSLog(@&quot;Fetched all messages.&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>用户登录后，首先加载缓存的消息，然后获取远程的消息，然后打印“Fetched all messages”</p><p>我们也可以方便的讲执行的操作移动到background queue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[[[[client</span><br><span class="line">fetchUserWithUsername:@&quot;joshaber&quot;]</span><br><span class="line">deliverOn:[RACScheduler scheduler]]</span><br><span class="line">map:^(User *user) &#123;</span><br><span class="line">// this is on a background queue</span><br><span class="line">return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];</span><br><span class="line">&#125;]</span><br><span class="line">deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">subscribeNext:^(NSImage *image) &#123;</span><br><span class="line">// now we&apos;re back on the main queue</span><br><span class="line">self.imageView.image = image;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>或者可以更简单的处理潜在的竞争条件，比如，我们可以使用异步操作中通过结果来更新属性，但是除非这个属性在异步操作完成前没有发生变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[[self</span><br><span class="line">loadDefaultMessageInBackground]</span><br><span class="line">takeUntil:RACAble(self.message)]</span><br><span class="line">toProperty:@keypath(self.message) onObject:self];</span><br></pre></td></tr></table></figure></p><p>###How does it work?<br>RAC从根本上来看是非常简单的，它是以信号的方式来流转数据。<a href="https://cvaieee.org/html/humor/programming_history.html" target="_blank" rel="noopener">Until you reach turtles.</a></p><p>Subscribers来订阅signals，Signals为它的订阅者发送 ’next’, ‘error’, ‘completed’事件，如果所有的事情都是signals来发送时间，那么关键的问题就编程了：这些事件会在什么时候被发送？</p><p>###Creating Signals<br>信号根据合适发送时间来定义自己的行为，我们可以通过+[RACSignal createSignal:]来创建自己的signal：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *helloWorld = [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:@&quot;Hello, &quot;];</span><br><span class="line">[subscriber sendNext:@&quot;world!&quot;];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">return nil;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>当这个signal获取一个新的订阅者，+[RACSignal createSignal:]会通过这个block进行回调。这个新的订阅者是通过里边的block我们可以发送这个事件。在上边的例子中，我们创建了一个signal会发送一个“hello”和“world”,然后发送完成。</p><p>##嵌套signal<br>我们可以基于helloWorld signal来创建另一个signal：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *joiner = [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">NSMutableArray *strings = [NSMutableArray array];</span><br><span class="line">return [helloWorld subscribeNext:^(NSString *x) &#123;</span><br><span class="line">[strings addObject:x];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendNext:[strings componentsJoinedByString:@&quot;&quot;]];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>现在我们有了一个joiner signal,当有订阅者订阅了joiner，它会定义我们的helloworld signal.</p><p>它从helloworld和helloword完成时候增加了所有数据的接收，它将所有接收到的string连接在一起，然后发送他们和完成</p><p>在这种方式，我们可以创建signal来表达一些复杂的行为。</p><p>RAC实现了一套<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/ead2c74fa619b30d161da36af9941af2ae123c5b/ReactiveCocoa/RACSignal%2BOperations.h" target="_blank" rel="noopener">operations</a>来恰好的实现他们，他们通过使用一些默认的行为来获取一些source signal 和返回一个新的signal</p><p>##More info<br><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>可以用于MAC和iOS开发，可以查看<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md" target="_blank" rel="noopener">README</a>来获取更多的信息，然后来导出MAC demo project 来获得一些实际的例子</p><p>对于.NET 开发者，所有这些听起来会很熟悉， ReactiveCocoa实际上是一个Objective-c版本的.NET  <a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103" target="_blank" rel="noopener">Reactive Extensions</a>)(Rx).</p><p>大多数的Rx规则应用于RAC上是非常合适的，这里是一些非常好的Rx资源：</p><ul><li><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103" target="_blank" rel="noopener">Reactive Extensions MSDN entry</a>)</li><li><a href="">Reactive Extensions for .NET Introduction</a></li><li><a href="https://channel9.msdn.com/tags/Rx/" target="_blank" rel="noopener">Rx – Channel 9 videos</a></li><li><a href="http://rxwiki.wikidot.com/" target="_blank" rel="noopener">Reactive Extensions wiki</a></li><li><a href="http://rxwiki.wikidot.com/101samples" target="_blank" rel="noopener">101 Rx Samples</a></li><li><a href="https://www.amazon.com/Programming-Reactive-Extensions-Jesse-Liberty/dp/1430237473" target="_blank" rel="noopener">Programming Reactive Extensions and LINQ</a> (Co-authored by our own <a href="https://github.com/paulcbetts" target="_blank" rel="noopener">Paul Betts</a>!)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;ReactiveCocoa创造更美好的世界&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;原文：&lt;a href=&quot;https://github.blog/2012-05-04-reactivecocoa-for-a-better-world/#async&quot; tar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>fastlane</title>
    <link href="https://www.cocoathinking.com/2019/02/25/fastlane/"/>
    <id>https://www.cocoathinking.com/2019/02/25/fastlane/</id>
    <published>2019-02-25T06:40:53.000Z</published>
    <updated>2019-02-25T06:41:47.735Z</updated>
    
    <content type="html"><![CDATA[<p>##使用背景<br>早些时候我一直使用python执行脚本来完成项目的持续集成，在Apple发布Xcode9的时候脚本进行了更新，部分脚本被废弃，在那时候我转移到fastlane阵营，原因很简单，fastlane使用更简单，更方便，我不再需要因为苹果对脚本的更新来被迫修改我的方案。</p><p>##fastlane介绍<br><a href="https://github.com/fastlane/fastlane" target="_blank" rel="noopener">fastlane</a>是一款持续集成工具，它的功能强大，使用简单，可以帮助我们处理一些费时的工作，比如生成截屏、处理配置文件、编译App、上传测试分发平台等。</p><blockquote><p>fastlane is a tool for iOS and Android developers to automate tedious tasks like generating screenshots, dealing with provisioning profiles, and releasing your application.</p></blockquote><p>###开始使用fastlance</p><p>####安装fastlance<br>安装Xcode command line tool的最新版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select —install</span><br></pre></td></tr></table></figure></p><p>使用工具安装fastlance<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#使用gem安装（确保你已经安装了ruby）</span><br><span class="line">sudo gem install fastlane -NV</span><br><span class="line"></span><br><span class="line">#或者使用Homebrew安装（确保已经安装了Homebrew）</span><br><span class="line">brew cask install fastlane</span><br></pre></td></tr></table></figure></p><p>####配置fastlane<br>在terminal中进入你的项目目录，执行以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane init</span><br></pre></td></tr></table></figure></p><p>接下来会根据你在安装时候的不同选择来创建不同的文件</p><ol><li>screenshots</li><li>TestFlight</li><li>AppStore</li><li>Manual<br>这里选择4.Manual就好了，其他的功能后续也可以在配置文件中手动添加<br>其中最需要注意的文件是fastlane/Fastfile，其中包含了你将要操作的所有信息</li></ol><p>####接下来要怎么做？<br>fastlane创建了所有的必要文件给我们，现在你可以通过配置这些文件进行持续化集成</p><p>###使用fastlane部署测试项目</p><p>####编译<br>fastlane 使用一个叫build_app的action来编译app，只要在Fastfile中加入下边代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lane :beta do</span><br><span class="line">build_app(scheme: &quot;MyApp&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>还可以在编译的时候加入其他的选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ane :beta do</span><br><span class="line">build_app(scheme: &quot;MyApp&quot;,</span><br><span class="line">workspace: &quot;Example.xcworkspace&quot;,</span><br><span class="line">include_bitcode: true)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>####上传app<br>在编译完成后可以上传到你选择的分发测试平台，在fastlane你可以很简单的做到这个工作，甚至不需要做额外的工作就可以同时上传多个平台<br>你可以选择上传的TestFlight，蒲公英，Fir，我们这里以蒲公英来举例：<br><a href="https://www.pgyer.com/doc/view/fastlane" target="_blank" rel="noopener">在这里</a>你可以找到蒲公英的上传文档，<br>你需要执行以下代码安装蒲公英插件<br>···<br>fastlane add_plugin pgyer<br>修改Fastfile，在build_app后添加蒲公英代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lane :beta do</span><br><span class="line">build_app(export_method: &quot;ad-hoc&quot;)</span><br><span class="line">pgyer(api_key: &quot;7f15xxxxxxxxxxxxxxxxxx141&quot;, user_key: &quot;4a5bcxxxxxxxxxxxxxxx3a9e&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>做完这些配置后，你就可以通过fastlane来打包App，并自动上传到蒲公英，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane beta，</span><br></pre></td></tr></table></figure></p><p>你可以打开<a href="https://www.pgyer.com/doc/view/fastlane" target="_blank" rel="noopener">蒲公英</a>，查看蒲公英提供的更多配置，比如添加密码，添加更新描述等。</p><p>接下来我会提供一个我正在用的Fastfile为大家提供参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line"></span><br><span class="line">lane :test do</span><br><span class="line">#添加版本更新描述</span><br><span class="line">puts &quot;请输入版本描述：&quot;</span><br><span class="line">#获取输入的描述</span><br><span class="line">desc = STDIN.gets</span><br><span class="line">#依次配置workspagce，scheme，build configuration，和export_method</span><br><span class="line">build_app(workspace: &quot;ProjectsName.xcworkspace&quot;, scheme: &quot;ProjectsName&quot;, configuration: &quot;Debug&quot;,export_method: &quot;development&quot;)</span><br><span class="line">#配置蒲公英的api_key,user_key,和输入的版本更新描述</span><br><span class="line">pgyer(api_key: &quot;59aa772ac06fe663xxxxxxxxxxxxxxx&quot;, user_key: &quot;0b18ced68eb3cc7xxxxxxxxxxxxxxxxxx&quot;, update_description: &quot;#&#123;desc&#125;&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>###总结<br>App的编译、打包、上传无趣又费时，使用fastlane可以提升效率，又可以节省我们的时间，不需要为了后续的操作一直盯着电脑。fastlane使用比较方便，这里我只是做一个简单的介绍，当然fastlane还提供了更多的功能，你可以在<a href="https://docs.fastlane.tools/" target="_blank" rel="noopener">fastlane主页</a>和<a href="https://github.com/fastlane/fastlane" target="_blank" rel="noopener">fastlane github</a>中找到更多的详细配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##使用背景&lt;br&gt;早些时候我一直使用python执行脚本来完成项目的持续集成，在Apple发布Xcode9的时候脚本进行了更新，部分脚本被废弃，在那时候我转移到fastlane阵营，原因很简单，fastlane使用更简单，更方便，我不再需要因为苹果对脚本的更新来被迫修改我
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Reactivecocoa全解析 2.常用操作和高阶函数</title>
    <link href="https://www.cocoathinking.com/2019/02/18/2-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://www.cocoathinking.com/2019/02/18/2-常用操作和高阶函数/</id>
    <published>2019-02-18T07:13:48.000Z</published>
    <updated>2019-02-19T08:42:31.151Z</updated>
    
    <content type="html"><![CDATA[<p>RAC现在分了两部分，ReactiveCocoaObjc和ReactiveCocoaSwift,本文介绍的均是 ReactiveCocoaObjc 2.5.0 版本的内容.</p><p>RAC的核心是信号源（RACStream），在RAC中，信号源代表随着时间而改变的流值，订阅者通过订阅信号来获取这些值，RACStream是一个抽象类，我们用到的最多的是它的之类 RACSignal和RACSequence，<br><em>以下代码和示例使用的ReactiveCocoa 2.5版本</em></p><a id="more"></a><p>介绍RAC的操作之前先介绍以下链式操作</p><p>链式操作：</p><p>用过Masonry的同学应该对链式操作不陌生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self.label mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line"></span><br><span class="line">make.top.left.mas_equalTo(0);</span><br><span class="line"></span><br><span class="line">make.centerY.mas_equalTo(self.view);</span><br><span class="line"></span><br><span class="line">make.width.height.mas_greaterThanOrEqualTo(0);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这里的make.top.left.mas_equalTo(0); 就是一个链式操作，执行一个方法后的返回结果接着执行下一个方法，前边我们已经讲到RAC使用的是FPR编程思想，所以在RAC中你同样可以使用链式操作</p><p>我们修改一下上边的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[[RACObserve(self, username)</span><br><span class="line"></span><br><span class="line">filter:^(NSString *newName) &#123;</span><br><span class="line"></span><br><span class="line">return [newName hasPrefix:@&quot;j&quot;];</span><br><span class="line"></span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">subscribeNext:^(NSString *newName) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, newName);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>订阅：subscribeNext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// When self.username changes, logs the new name to the console.</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// RACObserve(self, username) creates a new RACSignal that sends the current</span><br><span class="line"></span><br><span class="line">// value of self.username, then the new value whenever it changes.</span><br><span class="line"></span><br><span class="line">// -subscribeNext: will execute the block whenever the signal sends a value.</span><br><span class="line"></span><br><span class="line">[RACObserve(self, username) subscribeNext:^(NSString *newName) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, newName);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当username内容发生变化，就会打印出一个新的值。</p><p>RACObserve(TARGET, KEYPATH) 是RAC提供的一个宏，他可以创建一个新的signal，这里，我们通过subscribeNext方法对 signal进行订阅，当username内容发生变化时，就会在block中获取username的新值并进行打印</p><p>bind 对信号进行绑定，返回一个新的信号，它会订阅原信号的值，在bindingBlock中对原信号的值进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *orignSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line"></span><br><span class="line">[subscriber sendNext:@1];</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;orign signal dispose&quot;);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *newSignal = [orignSignal bind:^RACStreamBindBlock&#123;</span><br><span class="line"></span><br><span class="line">return ^(NSNumber *value, BOOL *stop)&#123;</span><br><span class="line"></span><br><span class="line">return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line"></span><br><span class="line">[subscriber sendNext:@(value.integerValue * 2)];</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;bind dispose&quot;);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[newSignal subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;newSignal value = %@&quot;, x);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>map:要完成对orign signal值得转换，使用map 和flattenMap是更简单的选择，这两个方法其实也是对bind方法的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *orignSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line"></span><br><span class="line">[subscriber sendNext:@1];</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;orign signal dispose&quot;);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[orignSignal map:^id(NSNumber *value) &#123;</span><br><span class="line"></span><br><span class="line">return @(value.integerValue * 2);</span><br><span class="line"></span><br><span class="line">&#125;]subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;new value is %@&quot;, x);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>flattenMap 返回的是一个新的signal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *newSignal2 = [orignSignal flattenMap:^RACStream *(NSNumber * value) &#123;</span><br><span class="line"></span><br><span class="line">return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line"></span><br><span class="line">[subscriber sendNext:@(value.integerValue * 2)];</span><br><span class="line"></span><br><span class="line">return nil;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[newSignal2 subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;new value2 is %@&quot;, x);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>filter:对seguence遍历后进行过滤，将不符合条件的数据进行过滤掉，返回一个新的sequence</p><p>nameArray.rac_sequence是将array转换为sequence，sequence代表了一个不可变的序列，它可以被订阅者订阅，而且还可以跟signal很方便的进行转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSArray *nameArray = @[@&quot;tom&quot;, @&quot;jerry&quot;, @&quot;tomas&quot;, @&quot;link&quot;];</span><br><span class="line"></span><br><span class="line">NSArray *resultArray = [nameArray.rac_sequence filter:^BOOL(NSString *name) &#123;</span><br><span class="line"></span><br><span class="line">return name.length &gt; 3;</span><br><span class="line"></span><br><span class="line">&#125;].array;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, resultArray);</span><br></pre></td></tr></table></figure><p>combineLatest 使用一个signal数组，当数组中的任意一个signal值发生变化时，就在block中对所有signal最后一个值进行处理，最后返回一个新的signal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.validLoginSignal = [[RACSignal combineLatest:@[RACObserve(self, username), RACObserve(self, password)] reduce:^(NSString *username, NSString *password)&#123;</span><br><span class="line"></span><br><span class="line">return @(username.isExist &amp;&amp; password.isExist);</span><br><span class="line"></span><br><span class="line">&#125;] distinctUntilChanged];</span><br></pre></td></tr></table></figure><p>zip 对多个信号的值进行压缩后创建一个RACTuples， zip将对每一个signal的值以配对的形式进行合并，比如signalA发送1和3，signal发送了2，那么合并后的Tuples包含了signal的1和signal的2。这里是zip和combineLatest最大的区别，在这里使用combineLatest会得到3和2，因为会重复利用signalB的旧值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line"></span><br><span class="line">[subscriber sendNext:@1];</span><br><span class="line"></span><br><span class="line">[subscriber sendNext:@3];</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">return nil;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; </span><br><span class="line"></span><br><span class="line">[subscriber sendNext:@2];</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">return nil;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[RACSignal zip:@[signalA, signalB]] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;zip %@&quot;, x); //==&gt;1，2</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[RACSignal combineLatest:@[signalA, signalB]] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;combineLatest: %@&quot;, x); //==&gt;3，2</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>merge</p><p>对多个signal进行合并，会监听到任意一个signal值得变化，并返回这个signal最新的值，当所有的signal发送complete时候会发送complate，当任意一个signal发送error立刻就发送error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal merge:@[signalA, signalB]] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;x = %@&quot;, x);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RAC现在分了两部分，ReactiveCocoaObjc和ReactiveCocoaSwift,本文介绍的均是 ReactiveCocoaObjc 2.5.0 版本的内容.&lt;/p&gt;
&lt;p&gt;RAC的核心是信号源（RACStream），在RAC中，信号源代表随着时间而改变的流值，订阅者通过订阅信号来获取这些值，RACStream是一个抽象类，我们用到的最多的是它的之类 RACSignal和RACSequence，&lt;br&gt;&lt;em&gt;以下代码和示例使用的ReactiveCocoa 2.5版本&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Reactivecocoa全解析 1.FRP编程思想</title>
    <link href="https://www.cocoathinking.com/2019/02/18/1-FRP%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <id>https://www.cocoathinking.com/2019/02/18/1-FRP编程思想/</id>
    <published>2019-02-18T07:09:30.000Z</published>
    <updated>2019-02-19T08:42:18.942Z</updated>
    
    <content type="html"><![CDATA[<p>ReactiveCocoa全解析 1.FRP编程思想</p><p>ReactiveCocoa是我在开发工作中重度使用的一个开源框架，当你使用MVVM设计模式的时候，它几乎是你最好的选择，当然你也可以使用其他的一些方式来完成数据绑定，KVO，delegate或者是block，但是RAC为你提供了更优雅更安全的绑定方式，我们可以使用RAC在View和ViewModel中充当binder的角色来实现数据的同步，也可以把RAC放在ViewModel层，使用signal来异步获取数据，比如网络请求，访问数据库等。 </p><p>因为RAC是一个使用起来并不那么容易的开源框架，所以接下来我会分几个部分来介绍它： </p><ol><li>FRP 的思想概要  （oop和fp）</li><li>RAC 的 operations 介绍</li><li>冷信号与热信号解惑</li><li>生命周期指南</li><li>disposable 和多线程</li><li>实战分享<a id="more"></a></li></ol><p>ReactiveCocoa是Gitbub开源的一个函数响应式编程框架，它是iOS上的函数响应式编程（FRP）体现，要理解RAC，首先我们就要理解函数响应式编程（FRP），刚开始接触FRP可能有一些困扰，因为它和我们以往的编程方式区别很大，接下来我们回顾一下现在常用的编程方式：面向对象编程（OOP）和面向协议编程（POP）</p><p>###面向对象编程（OOP<br>从我们刚开始学习编程，接触到的最多就是面向对象编程（OOP），OOP的优点很多，继承，抽象，多态，可重用性，可维护性等等，我们从很早就知道了万物皆可盘（误 ，应该是万物皆对象的编程思想，当然有人也有一些质疑，比如结构体和对象的关系等，抛开这些争论，面向对象仍然是一种灵活的，易于维护的编程方式。</p><p>###面向协议编程（POP）<br>面向协议编程（POP）是我在使用Swift时用到的编程方式。我在15-16年中使用Swift来完成编程工作，现在因为一些原因我又回到了Objective-C阵营，但我仍无比的怀念Swift，其中一个重要原因，就是Swift对面向协议编程的友好支持。</p><blockquote><p>苹果公司声明：从核心上说，Swift是面向协议的</p></blockquote><p>POP拥有OOP的大部分特点，他们之间最大的区别是：类只能继承一个类（这里只讨论iOS开发语言，像一些编程语言比如C++的确拥有多继承，但是多继承在工作中仍然不是一个很好的特性），而类可以实现多个协议。我们可以举一个例子，如果现在要创建漫威英雄的类，我们要怎么创建？</p><p>创建一个父类,拥有fly，land方法， SuperHero：fly（），land()</p><p>子类Super Man：</p><p>子类Iron Man：</p><p>子类Spider Man：</p><p>我们都知道小蜘蛛是没有飞行能力的，所以在这里将fly和land方法放在父类中并不可行，我们必须在父类删除fly和land，在超人和钢铁侠中单独加入fly和land，但是拥有飞行能力的超级英雄并不少见，我们接下来不得不为猎鹰，幻世，绯红女巫他们挨个加上。所以面向对象在这里并不是很可靠，换个思路，这里我们用POP试一下</p><p>创建一个fly协议，拥有fly和land两个方法，因为飞行和降落都是对应的，所以这里没有什么问题，接下来我们只要将拥有飞行能力的超级英雄实现fly协议，这样使用这个fly协议的超级英雄就拥有了飞行能力，当然我们也可以建立更多的协议，来为超级英雄增加更多的能力。</p><p>编程思想并没有孰优孰劣，我们这里只是做一个简单介绍，接下介绍一下今天的重点，函数响应式编程（FRP）。</p><p>###函数响应式编程（FRP）<br>FRP全称Function Reactive Programing，它包含了两个部分，函数式编程 Function  Programing（FP）和响应式编程  Reactive Programing（RP）,</p><p>####响应式编程 </p><p>我们先来看一段代码，</p><p>int a  = 3;</p><p>int b  = 5;</p><p>int c = a + b;</p><p>a = 8;</p><p>NSLog(@“c = %d”, c); //8</p><p>这是我们熟悉的编程方式，首先为a和b进行赋值，然后将a + b的指赋给c，打印c的结果为8，接下来修改a和b的值后重新打印c，此时c的值仍然是8。因为代码中的  a + b只是一个瞬时的操作，并不是一段关系的描述。</p><p>而响应式编程是一种面向数据流和变化传播的编程范式，这意味着可以再编程语言中很方便的表达静态和动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播，所以在响应式编程中，上述例子中的c 会跟根据a、b值得变化而发生变化</p><p>在app的登录界面中，我们常常需要通过判断用户名和密码是否填写合法后来设置登陆按钮的可点击状态，这里我们可以对userNameTextField和passwordTextField进行监听，然后将监听的结果合并后进行合法性判断，最后将处理的结果绑定到登陆按钮上，这在RAC中是一个最常用的写法，当userNameTextField和passwordTextField发生变化时，登陆按钮的状态会相应的发生变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.viewModel, username) = self.usernameTexField.rac_textSignal;</span><br><span class="line"></span><br><span class="line">RAC(self.viewModel, password) = self.passwordTextField.rac_textSignal;</span><br><span class="line"></span><br><span class="line">self.validLoginSignal = [[RACSignal combineLatest:@[RACObserve(self, username), </span><br><span class="line"></span><br><span class="line">RACObserve(self, password)] reduce:^(NSString *username, NSString *password)&#123;</span><br><span class="line">return @(username.isExist &amp;&amp; password.isExist);</span><br><span class="line">&#125;] distinctUntilChanged];</span><br><span class="line"></span><br><span class="line">RAC(self.loginButton, enabled) = self.viewModel.validLoginSignal;</span><br></pre></td></tr></table></figure><p>​<br>​<br>​ 另外一个典型的例子，在iOS开发中我们用Autolayout设置约束来描述视图之间的位置关系，当某一个约束发生改变后，其他的约束就会响应发生变化，这里也是响应式编程的体现。<br>​<br>​ ####函数式编程<br>​<br>​ 函数式编程将计算机运算视为函数运算，并且避免使用程序状态和易变对象，在函数式编程中函数可以像其他数据类型一样，处于平等的地位，可以作为参数传递到另一个函数中，可以赋值给其他的变量，也可以做为别的函数的返回值。<br>​<br>​ 我们可以使用RAC提供的一系列高阶函数来实现函数式编程，比如map，falltenMap,,filter,reduce,merge,combinte等等，在接下来的文章中我会介绍一下RAC为我们提供的常用的高阶函数。<br>​<br>​<br>​ 到这里大家应该已经对FRP编程思想有一些认识，接下来我会介绍以下RAC为我们提供的高阶函数，已经如何如果使用它们来解决开发工作中可能遇到的一些问题。<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​ 说了这么多，那么使用FRP到底有什么好处呢，我觉得使用FRP可以为我们解决以下几个问题：<br>​<br>​ 过多的状态值<br>​<br>​ vc中的冗余代码<br>​<br>​ 消息传递机制<br>​<br>​ Event之间的组合，交互<br>​<br>​ 多请求的处理<br>​ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactiveCocoa全解析 1.FRP编程思想&lt;/p&gt;
&lt;p&gt;ReactiveCocoa是我在开发工作中重度使用的一个开源框架，当你使用MVVM设计模式的时候，它几乎是你最好的选择，当然你也可以使用其他的一些方式来完成数据绑定，KVO，delegate或者是block，但是RAC为你提供了更优雅更安全的绑定方式，我们可以使用RAC在View和ViewModel中充当binder的角色来实现数据的同步，也可以把RAC放在ViewModel层，使用signal来异步获取数据，比如网络请求，访问数据库等。 &lt;/p&gt;
&lt;p&gt;因为RAC是一个使用起来并不那么容易的开源框架，所以接下来我会分几个部分来介绍它： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;FRP 的思想概要  （oop和fp）&lt;/li&gt;
&lt;li&gt;RAC 的 operations 介绍&lt;/li&gt;
&lt;li&gt;冷信号与热信号解惑&lt;/li&gt;
&lt;li&gt;生命周期指南&lt;/li&gt;
&lt;li&gt;disposable 和多线程&lt;/li&gt;
&lt;li&gt;实战分享
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cocoaThinking重启计划</title>
    <link href="https://www.cocoathinking.com/2019/02/01/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF/"/>
    <id>https://www.cocoathinking.com/2019/02/01/博客重启/</id>
    <published>2019-02-01T08:37:17.000Z</published>
    <updated>2019-02-01T08:43:55.526Z</updated>
    
    <content type="html"><![CDATA[<p>我在2015年开通了自己的博客，博客通过hexo+github搭建，博客开通的虽早，但是写作确没有怎么坚持下来，2015年到现在零零散散的写了不到10篇，多数还是在15年趁着刚刚搭建完的热乎劲写成，实在汗颜。2019阴历新年马上就要到了，我决定制定一个cocoaThinking重启计划，一方面写一写技术总结，另一方面也有地方可以写一下日常的生活点滴。<br>这次博客的重启，我更新了一些必要工具，hexo，node，npm，还有hexo的模板Next，更新的时候我发现node的版本从当时的0.10升级到了11.15，hexo和next也都完成多个版本的升级，不得不感慨时光匆匆，几年的时间过的真快，当时搭建博客的时候和我的同事showndu一起研究讨论问题的场景还是历历在目，这也更坚定了我对这次重启计划的决心。<br>看了一下自己以前写的文章，多数因为年代久远已经过时了，剩下的几篇比如《iOS常用设计模式》，因为当时的自己较为年轻，写的文章也有很多不足。所以会对之前的文章进行清理，过时的删掉，不足的会进行修改补充。接下来先完成这部分工作吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我在2015年开通了自己的博客，博客通过hexo+github搭建，博客开通的虽早，但是写作确没有怎么坚持下来，2015年到现在零零散散的写了不到10篇，多数还是在15年趁着刚刚搭建完的热乎劲写成，实在汗颜。2019阴历新年马上就要到了，我决定制定一个cocoaThinki
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS9 Search API NSUserActivity</title>
    <link href="https://www.cocoathinking.com/2015/09/25/NSUserActivity/"/>
    <id>https://www.cocoathinking.com/2015/09/25/NSUserActivity/</id>
    <published>2015-09-25T03:33:47.000Z</published>
    <updated>2015-09-25T03:49:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在WWDC2015会议上，苹果公布了iOS9系统，iOS9系统相比iOS7、iOS8并没有特别大得变化，可以看做是iOS8的基础上进行的平滑的过度。但是新的系统中仍有一些特性和功能值得人们去关注，其中<br>Search API就是其中之一。通过新的Search API可以实现强大的应用内搜索功能，通过在Spotlight中使用我们设计的所以，来查看app中的界面或是内容。</p><h4 id="iOS9的-Search-API由三个组件组成："><a href="#iOS9的-Search-API由三个组件组成：" class="headerlink" title="iOS9的 Search API由三个组件组成："></a>iOS9的 Search API由三个组件组成：</h4><p>1.NSUserActivity<br>2.Web Markup<br>3.Core Spotlight<br>现在介绍一下NSUserActivity的使用<br>NSUserActivity是在iOS8中出现的API，主要用户HandOff功能，iOS9中NSUserActivity新增加了一个属性 eligibleForSearch 来控制在Spotlight中的显示<br><a id="more"></a></p><p>定义一个NSUserActivity属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong)NSUserActivity *activity;</span><br></pre></td></tr></table></figure></p><p>初始化NSUserActivity,并设置属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//ActivityType为唯一标识</span><br><span class="line">_activity = [[NSUserActivity alloc]initWithActivityType:@&quot;Eden&quot;];</span><br><span class="line"></span><br><span class="line">//title app在Spotlight中显示的名称，可以和app名称不一样，多个app使用相同的keywords，初始通过title名称进行排序</span><br><span class="line">_activity.title = @&quot;Eden&quot;;</span><br><span class="line"></span><br><span class="line">//Spolight搜索关键字</span><br><span class="line">_activity.keywords = [NSSet setWithArray:@[@&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Eve&quot;]];</span><br><span class="line"></span><br><span class="line">//关闭HandOff功能</span><br><span class="line">_activity.eligibleForHandoff = NO;</span><br><span class="line"></span><br><span class="line">//开启Spotlight search功能</span><br><span class="line">_activity.eligibleForSearch = YES;</span><br><span class="line"></span><br><span class="line">//开启NSUserActivity</span><br><span class="line">[_activity becomeCurrent];</span><br></pre></td></tr></table></figure></p><p>当做完这些操作时候然后运行程序，我们在spotlight中搜索 adam, lilith, eva中的某一个关键字就会找到我们的应用，此时选择应用会直接跳转到app的首页。有时候我们希望最好能通过某个关键字直接跳转到app其中某一页，幸运的是NSUserActivity同样支持这个功能。</p><h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h4><p>创建AdmaViewController，LilithViewController<br>我们在AdmaViewController中创建adamUserActivity,title为adamView, 关键字adam<br>我们在LilithViewController中创建lilithUserActivity, title为lilithView,关键字lilith<br>可以在首页通过adam跳转到admaViewController<br>可以在首页通过lilith跳转到lilithViewController</p><h4 id="开始工作："><a href="#开始工作：" class="headerlink" title="开始工作："></a>开始工作：</h4><p>找到AppDelegate文件，添加方法</p><p>//在主线程下存在可用NSUserActivity对象时候调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123;</span><br><span class="line"></span><br><span class="line">//找到当前的window的rootView转换为UINavigationController(如果你的rootView是UINavigationController的话)</span><br><span class="line">    UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;</span><br><span class="line"></span><br><span class="line">//找到navigationController的topView（首页） 中restoreUserActivityState方法</span><br><span class="line">    [navigationController.topViewController restoreUserActivityState:userActivity];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 在首页中重写restoreUserActivityState方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)restoreUserActivityState:(NSUserActivity *)activity&#123;</span><br><span class="line">//通过Spotlight中传过来的NSUserActivity对象的title判断具体跳转到哪一页</span><br><span class="line">    if ([activity.title isEqualToString:@&quot;Adam&quot;]) &#123;</span><br><span class="line">        AdamViewController *adamView = [[AdamViewController alloc]init];</span><br><span class="line">        [self.navigationController pushViewController:adamView animated:YES];</span><br><span class="line">    &#125;else if([activity.title isEqualToString:@&quot;Lilith&quot;])&#123;</span><br><span class="line">        LilithViewController *lilithView = [[LilithViewController alloc]init];</span><br><span class="line">        [self.navigationController pushViewController:lilithView animated:YES];</span><br><span class="line">    &#125;else  if([activity.title isEqualToString:@&quot;Eve&quot;])&#123;</span><br><span class="line">        EveViewController *eveView = [[EveViewController alloc]init];</span><br><span class="line">        [self.navigationController pushViewController:eveView animated:YES];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当选择再Spotlight中搜索adam，选择应用会直接跳转到 adamViewController中，搜索lilith关键字，选择应用会直接跳转到lilithViewController中</p><p><a href="https://github.com/Lilin233/iOS9NSUserActivity" target="_blank" rel="noopener">本文代码下载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在WWDC2015会议上，苹果公布了iOS9系统，iOS9系统相比iOS7、iOS8并没有特别大得变化，可以看做是iOS8的基础上进行的平滑的过度。但是新的系统中仍有一些特性和功能值得人们去关注，其中&lt;br&gt;Search API就是其中之一。通过新的Search API可以实现强大的应用内搜索功能，通过在Spotlight中使用我们设计的所以，来查看app中的界面或是内容。&lt;/p&gt;
&lt;h4 id=&quot;iOS9的-Search-API由三个组件组成：&quot;&gt;&lt;a href=&quot;#iOS9的-Search-API由三个组件组成：&quot; class=&quot;headerlink&quot; title=&quot;iOS9的 Search API由三个组件组成：&quot;&gt;&lt;/a&gt;iOS9的 Search API由三个组件组成：&lt;/h4&gt;&lt;p&gt;1.NSUserActivity&lt;br&gt;2.Web Markup&lt;br&gt;3.Core Spotlight&lt;br&gt;现在介绍一下NSUserActivity的使用&lt;br&gt;NSUserActivity是在iOS8中出现的API，主要用户HandOff功能，iOS9中NSUserActivity新增加了一个属性 eligibleForSearch 来控制在Spotlight中的显示&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://www.cocoathinking.com/categories/iOS/"/>
    
    
      <category term="iOS9" scheme="https://www.cocoathinking.com/tags/iOS9/"/>
    
      <category term="Search API" scheme="https://www.cocoathinking.com/tags/Search-API/"/>
    
      <category term="NSUserActivity" scheme="https://www.cocoathinking.com/tags/NSUserActivity/"/>
    
  </entry>
  
  <entry>
    <title>NSArray和NSMutableArray</title>
    <link href="https://www.cocoathinking.com/2015/08/26/%E6%95%B0%E7%BB%84/"/>
    <id>https://www.cocoathinking.com/2015/08/26/数组/</id>
    <published>2015-08-26T14:09:39.000Z</published>
    <updated>2015-08-26T14:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组作为存储对象的有序集合，可能是平时用到的最多的集合类。NS数组中存放的是Fundation对象，简单类型比如int，float等可以封装为NSNumber对象来存放到数组中。<br>Objc中数组分为不可变数组和可变数组，可变数组使用NSMutableArray来处理，不可变数组为NSArray，NSMutableArray是NSArray的子类，也就是说继承了NSArray得所有方法</p><h3 id="1-创建一个数组"><a href="#1-创建一个数组" class="headerlink" title="1.创建一个数组"></a>1.创建一个数组</h3><p>创建一个NSArray<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = [NSArray arrayWithObjects:@1, @2, @3, nil];</span><br><span class="line"></span><br><span class="line">NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:10];</span><br><span class="line"></span><br><span class="line">NSMutableArray *array2 = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:0];</span><br></pre></td></tr></table></figure></p><blockquote><p>使用initWithCapacity方法可以在初始化数组的时候添加一个预留空间，在数组空间超过这个预留空间时候会进行自动追加。不过是再测试中发现这样做并没有提高应有的效率，传言苹果实际上没有采用这个参数。不过这样有个好处是可以做为一个隐性文档来提高代码可读性。<br><a id="more"></a></p></blockquote><p>在创建NSArray数组的时候也可以使用语法糖，相对于调用方法更加简单快捷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];</span><br></pre></td></tr></table></figure></p><h3 id="2-NSArray-和NSMutableArray-转换"><a href="#2-NSArray-和NSMutableArray-转换" class="headerlink" title="2.NSArray 和NSMutableArray 转换"></a>2.NSArray 和NSMutableArray 转换</h3><p>//NSMutableArray 转换NSArray<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建可变数组</span><br><span class="line">NSMutableArray *mutableArray = [NSMutableArray array];</span><br><span class="line">// 使用copy方法获得一个NSArray。使用三木运算符判断当NSArray为nil时候重新初始化一个新的对象</span><br><span class="line">// x?:y == x?x:y;  </span><br><span class="line">NSArray *array = [mutableArray copy]?:[NSArray array];</span><br></pre></td></tr></table></figure></p><p>//NSArray 转换NSMutableArray<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化一个NSArray</span><br><span class="line">NSArray *array = @[@7, @2 ,@0 ,@1, @6, @8, @3] ;</span><br><span class="line">// 使用mutableCopy方法获得一个NSMutableArray</span><br><span class="line">NSMutableArray *mutableArray = [array mutableCopy]?:[NSMutableArray array];</span><br><span class="line">//使用类方法arrayWithArray进行转换</span><br><span class="line">NSMutableArray *mutableArray2 = [NSMutableArray arrayWithArray:array];</span><br></pre></td></tr></table></figure></p><h3 id="3-查找对象"><a href="#3-查找对象" class="headerlink" title="3.查找对象"></a>3.查找对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id object  = [array objectAtIndex:index];</span><br></pre></td></tr></table></figure><p>同样可以通过语法糖获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id object = array[index];</span><br></pre></td></tr></table></figure></p><p>NSArray提供firstObject, lastObject,方法获取数组的首尾对象，当数组为空时候返回nil。而使用常规方法获取空数组中的对象则会返回NSRangeException异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id lastObject  = [array lastObject];</span><br><span class="line">id firstObject = [array firstObject];</span><br></pre></td></tr></table></figure></p><p>为了方便数组中数据量很大的情况下查找数据，苹果已经预先实现二分查找法来遍历数组，这样查询效率将大大提高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];</span><br><span class="line">NSMutableArray *mutableArray = [NSMutableArray array];</span><br><span class="line">NSRange range = NSMakeRange(0, 5);</span><br><span class="line">NSInteger index = [array indexOfObject:@0 inSortedRange:range options:NSBinarySearchingInsertionIndex usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">    if (obj1 &lt; obj2) &#123;</span><br><span class="line">        return NSOrderedAscending;</span><br><span class="line">    &#125;</span><br><span class="line">        return NSOrderedDescending;</span><br><span class="line">&#125;];</span><br><span class="line">id object = mutableArray[index];</span><br></pre></td></tr></table></figure></p><h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4.排序"></a>4.排序</h3><p>有很多方法可以对数组进行排序，如果数组中存放的是字符串对象，可以使用sortedArrayUsingSelector:方法进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;];</span><br><span class="line">NSArray *newArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];</span><br></pre></td></tr></table></figure></p><p>如果数组存放的是数字，可以使用compare:方法进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@4, @0, @8, @9, @11];</span><br><span class="line">NSArray *newArray = [array sortedArrayUsingSelector:@selector(compare:)];</span><br></pre></td></tr></table></figure></p><p>可是使用reverseObjectEnumerator.allObjects获得一个数组的逆序排列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@4, @0, @8, @9, @11];</span><br><span class="line">NSArray *newArray = array.reverseObjectEnumerator.allObjects;</span><br></pre></td></tr></table></figure></p><h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><p>从一个数组过滤一些元素，组成另一个数组使我们经常遇到的一个场景，同样Objc提供了很多方法可以实现<br>1.快速枚举 NSFastEnumeration(for in)<br>使用快速枚举在数组数据量较大的情况下效率会比传统的for循环提高很多，而且快速枚举代码的可读性也更高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];</span><br><span class="line">NSMutableArray *newArray = [NSMutableArray array];</span><br><span class="line">for (NSString *godName in array) &#123;</span><br><span class="line">    if ([godName containsString:@&quot;l&quot;]) &#123;                        [newArray addObject:godName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">NSLog(@&quot;%@&quot;,newArray);</span><br></pre></td></tr></table></figure></p><p>2.使用indexesOfObjectsWithOptions方法<br>当数据量很大的情况下，使用indexesOfObjectsWithOptions方法的NSEnumerationConcurrent参数可以开启同步执行，但这也只是在数据量很大的情况下，当数据量较少时候因为需要额外的线程管理效率会变得更低一些<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];</span><br><span class="line">NSIndexSet *indexSet = [array indexesOfObjectsWithOptions:NSEnumerationConcurrent passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    if ([obj isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">        NSString *godName = obj;</span><br><span class="line">        if ([godName containsString:@&quot;l&quot;]) &#123;</span><br><span class="line">                    return obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">NSArray *newArray = [array objectsAtIndexes:indexSet];</span><br><span class="line">NSLog(@&quot;%@&quot;,newArray);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组作为存储对象的有序集合，可能是平时用到的最多的集合类。NS数组中存放的是Fundation对象，简单类型比如int，float等可以封装为NSNumber对象来存放到数组中。&lt;br&gt;Objc中数组分为不可变数组和可变数组，可变数组使用NSMutableArray来处理，不可变数组为NSArray，NSMutableArray是NSArray的子类，也就是说继承了NSArray得所有方法&lt;/p&gt;
&lt;h3 id=&quot;1-创建一个数组&quot;&gt;&lt;a href=&quot;#1-创建一个数组&quot; class=&quot;headerlink&quot; title=&quot;1.创建一个数组&quot;&gt;&lt;/a&gt;1.创建一个数组&lt;/h3&gt;&lt;p&gt;创建一个NSArray&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray *array = [NSArray arrayWithObjects:@1, @2, @3, nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:10];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *array2 = [NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用initWithCapacity方法可以在初始化数组的时候添加一个预留空间，在数组空间超过这个预留空间时候会进行自动追加。不过是再测试中发现这样做并没有提高应有的效率，传言苹果实际上没有采用这个参数。不过这样有个好处是可以做为一个隐性文档来提高代码可读性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS常用设计模式</title>
    <link href="https://www.cocoathinking.com/2015/08/12/iOS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.cocoathinking.com/2015/08/12/iOS常用设计模式/</id>
    <published>2015-08-12T09:04:17.000Z</published>
    <updated>2015-08-12T09:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>所有的iPhone应用程序都是基于UIKit框架构建而成的，所以它们在本质上具有相同的核心架构。</p><blockquote><p>UIKit框架的设计模式 结合了很多在Mac OS X Cocoa应用程序中使用的设计模式，理解这些设计模式对于创建iPhone程序是很关键的。</p></blockquote><h3 id="1-模型-视图-控制器模式-MVC模式"><a href="#1-模型-视图-控制器模式-MVC模式" class="headerlink" title="1.模型-视图-控制器模式 MVC模式"></a>1.模型-视图-控制器模式 MVC模式</h3><p>模型-视图-控制器模式(model-view-controller)简称MVC模式，它将您的代码独立分割为几个部分。模型部分定义应用程序的数据引擎，负责维护数据的完整性；视图定义应用程序的用户界面；控制器则充当模型和视图的桥梁，负责实现数据和现实的更新。<br><a id="more"></a></p><h3 id="2-目标-动作"><a href="#2-目标-动作" class="headerlink" title="2.目标-动作"></a>2.目标-动作</h3><p>控件通过目标-动作的模式将用户的交互通知您的应用程序，当用户以预先定义好的动作（比如点击一个按钮）进行交互时，空间就会将消息（动作）发送给您制定的对象（目标）。接收到动作消息后，目标对象就会以恰当的方式相应（比如按动按钮的时候刷新应用程序的状态）。</p><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><p>单例模式确保一个给定类只有一个实例出现，这个实例有一个全局的访问点，它通常使用懒加载的时候在第一次使用的时候再取加载<br>注意：苹果使用了大量的单例模式，我们用到的[UIAppliacation shareapplication],[UIScreen mainscreen],[NSUserDefaults standardUserDefaults] 等返回的都是一个单例对象。<br>在一些情况下使用单例模式会是非常合理的，比如你需要一个全局配置处理类，使用单例模式就会很好的实现。<br>使用GCD的方式可以很容易实现一个单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+(Singelton)shareInstance&#123;</span><br><span class="line"> // 1</span><br><span class="line"> static Singelton *st;</span><br><span class="line"> // 2</span><br><span class="line"> static dispatch_once_t onceToken;</span><br><span class="line"> // 3</span><br><span class="line"> dispatch_once(&amp;onceToken,^&#123;</span><br><span class="line"> st =[[Singelton alloc]init];</span><br><span class="line"> &#125;);</span><br><span class="line"> return st;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中有三个需要注意的地方：</p><ol><li>声明一个static静态变量保存实例变量，确保它在类中的全局可用性。</li><li>声明一个static静态dispath_once_t，确保初始化代码只执行一次</li><li>使用 Grand Center Dispatch (GCD)执行Singelton变量block，正式单例模式的关键，一旦类被初始化，初始化器就不会再被调用<br>下次再调用shareInstance的时候，dispatch_once块中得代码将不会执行（因为他已经被执行了一次），你将得到已经初始化好的类</li></ol><h3 id="4-代理设计模式"><a href="#4-代理设计模式" class="headerlink" title="4.代理设计模式"></a>4.代理设计模式</h3><p>代理设计模式  一个对象提供机会对另一个对象发生变化时候做出反应。<br>代理模式基本思想：两个对象协同解决问题，通常用于对象之间的通信</p><p>Cocoa 框架中同样运用了大量的代理模式，每个UI控件后边都声明了一个id类型的delegate或是datasource，比如说最常用到的UITableView 控件头文件中声明了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (notamatic, assign)id &lt;UITableViewDataSource&gt; datasource;  </span><br><span class="line">@property (notamatic, assign)id &lt;UITableViewDelegate&gt; delegate;</span><br></pre></td></tr></table></figure></p><p>即这个代理要遵循某一个协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有的iPhone应用程序都是基于UIKit框架构建而成的，所以它们在本质上具有相同的核心架构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UIKit框架的设计模式 结合了很多在Mac OS X Cocoa应用程序中使用的设计模式，理解这些设计模式对于创建iPhone程序是很关键的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-模型-视图-控制器模式-MVC模式&quot;&gt;&lt;a href=&quot;#1-模型-视图-控制器模式-MVC模式&quot; class=&quot;headerlink&quot; title=&quot;1.模型-视图-控制器模式 MVC模式&quot;&gt;&lt;/a&gt;1.模型-视图-控制器模式 MVC模式&lt;/h3&gt;&lt;p&gt;模型-视图-控制器模式(model-view-controller)简称MVC模式，它将您的代码独立分割为几个部分。模型部分定义应用程序的数据引擎，负责维护数据的完整性；视图定义应用程序的用户界面；控制器则充当模型和视图的桥梁，负责实现数据和现实的更新。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
