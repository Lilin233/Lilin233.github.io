<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cocoaThinking重启计划]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF%2F</url>
    <content type="text"><![CDATA[我在2015年开通了自己的博客，博客通过hexo+github搭建，博客开通的虽早，但是写作确没有怎么坚持下来，2015年到现在零零散散的写了不到10篇，多数还是在15年趁着刚刚搭建完的热乎劲写成，实在汗颜。2019阴历新年马上就要到了，我决定制定一个cocoaThinking重启计划，一方面写一写技术总结，另一方面也有地方可以写一下日常的生活点滴。这次博客的重启，我更新了一些必要工具，hexo，node，npm，还有hexo的模板Next，更新的时候我发现node的版本从当时的0.10升级到了11.15，hexo和next也都完成多个版本的升级，不得不感慨时光匆匆，几年的时间过的真快，当时搭建博客的时候和我的同事showndu一起研究讨论问题的场景还是历历在目，这也更坚定了我对这次重启计划的决心。看了一下自己以前写的文章，多数因为年代久远已经过时了，剩下的几篇比如《iOS常用设计模式》，因为当时的自己较为年轻，写的文章也有很多不足。所以会对之前的文章进行清理，过时的删掉，不足的会进行修改补充。接下来先完成这部分工作吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS9 Search API NSUserActivity]]></title>
    <url>%2F2015%2F09%2F25%2FNSUserActivity%2F</url>
    <content type="text"><![CDATA[在WWDC2015会议上，苹果公布了iOS9系统，iOS9系统相比iOS7、iOS8并没有特别大得变化，可以看做是iOS8的基础上进行的平滑的过度。但是新的系统中仍有一些特性和功能值得人们去关注，其中Search API就是其中之一。通过新的Search API可以实现强大的应用内搜索功能，通过在Spotlight中使用我们设计的所以，来查看app中的界面或是内容。 iOS9的 Search API由三个组件组成：1.NSUserActivity2.Web Markup3.Core Spotlight现在介绍一下NSUserActivity的使用NSUserActivity是在iOS8中出现的API，主要用户HandOff功能，iOS9中NSUserActivity新增加了一个属性 eligibleForSearch 来控制在Spotlight中的显示 定义一个NSUserActivity属性1@property (nonatomic, strong)NSUserActivity *activity; 初始化NSUserActivity,并设置属性1234567891011121314151617//ActivityType为唯一标识_activity = [[NSUserActivity alloc]initWithActivityType:@&quot;Eden&quot;];//title app在Spotlight中显示的名称，可以和app名称不一样，多个app使用相同的keywords，初始通过title名称进行排序_activity.title = @&quot;Eden&quot;;//Spolight搜索关键字_activity.keywords = [NSSet setWithArray:@[@&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Eve&quot;]];//关闭HandOff功能_activity.eligibleForHandoff = NO;//开启Spotlight search功能_activity.eligibleForSearch = YES;//开启NSUserActivity[_activity becomeCurrent]; 当做完这些操作时候然后运行程序，我们在spotlight中搜索 adam, lilith, eva中的某一个关键字就会找到我们的应用，此时选择应用会直接跳转到app的首页。有时候我们希望最好能通过某个关键字直接跳转到app其中某一页，幸运的是NSUserActivity同样支持这个功能。 准备工作：创建AdmaViewController，LilithViewController我们在AdmaViewController中创建adamUserActivity,title为adamView, 关键字adam我们在LilithViewController中创建lilithUserActivity, title为lilithView,关键字lilith可以在首页通过adam跳转到admaViewController可以在首页通过lilith跳转到lilithViewController 开始工作：找到AppDelegate文件，添加方法 //在主线程下存在可用NSUserActivity对象时候调用123456789- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123;//找到当前的window的rootView转换为UINavigationController(如果你的rootView是UINavigationController的话) UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;//找到navigationController的topView（首页） 中restoreUserActivityState方法 [navigationController.topViewController restoreUserActivityState:userActivity]; return YES;&#125; 在首页中重写restoreUserActivityState方法 1234567891011121314- (void)restoreUserActivityState:(NSUserActivity *)activity&#123;//通过Spotlight中传过来的NSUserActivity对象的title判断具体跳转到哪一页 if ([activity.title isEqualToString:@&quot;Adam&quot;]) &#123; AdamViewController *adamView = [[AdamViewController alloc]init]; [self.navigationController pushViewController:adamView animated:YES]; &#125;else if([activity.title isEqualToString:@&quot;Lilith&quot;])&#123; LilithViewController *lilithView = [[LilithViewController alloc]init]; [self.navigationController pushViewController:lilithView animated:YES]; &#125;else if([activity.title isEqualToString:@&quot;Eve&quot;])&#123; EveViewController *eveView = [[EveViewController alloc]init]; [self.navigationController pushViewController:eveView animated:YES]; &#125;&#125; 现在当选择再Spotlight中搜索adam，选择应用会直接跳转到 adamViewController中，搜索lilith关键字，选择应用会直接跳转到lilithViewController中 本文代码下载地址]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS9</tag>
        <tag>Search API</tag>
        <tag>NSUserActivity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSArray和NSMutableArray]]></title>
    <url>%2F2015%2F08%2F26%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组作为存储对象的有序集合，可能是平时用到的最多的集合类。NS数组中存放的是Fundation对象，简单类型比如int，float等可以封装为NSNumber对象来存放到数组中。Objc中数组分为不可变数组和可变数组，可变数组使用NSMutableArray来处理，不可变数组为NSArray，NSMutableArray是NSArray的子类，也就是说继承了NSArray得所有方法 1.创建一个数组创建一个NSArray1234567NSArray *array = [NSArray arrayWithObjects:@1, @2, @3, nil];NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:10];NSMutableArray *array2 = [NSMutableArray array];NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:0]; 使用initWithCapacity方法可以在初始化数组的时候添加一个预留空间，在数组空间超过这个预留空间时候会进行自动追加。不过是再测试中发现这样做并没有提高应有的效率，传言苹果实际上没有采用这个参数。不过这样有个好处是可以做为一个隐性文档来提高代码可读性。 在创建NSArray数组的时候也可以使用语法糖，相对于调用方法更加简单快捷1NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;]; 2.NSArray 和NSMutableArray 转换//NSMutableArray 转换NSArray12345// 创建可变数组NSMutableArray *mutableArray = [NSMutableArray array];// 使用copy方法获得一个NSArray。使用三木运算符判断当NSArray为nil时候重新初始化一个新的对象// x?:y == x?x:y; NSArray *array = [mutableArray copy]?:[NSArray array]; //NSArray 转换NSMutableArray123456//初始化一个NSArrayNSArray *array = @[@7, @2 ,@0 ,@1, @6, @8, @3] ;// 使用mutableCopy方法获得一个NSMutableArrayNSMutableArray *mutableArray = [array mutableCopy]?:[NSMutableArray array];//使用类方法arrayWithArray进行转换NSMutableArray *mutableArray2 = [NSMutableArray arrayWithArray:array]; 3.查找对象1id object = [array objectAtIndex:index]; 同样可以通过语法糖获取1id object = array[index]; NSArray提供firstObject, lastObject,方法获取数组的首尾对象，当数组为空时候返回nil。而使用常规方法获取空数组中的对象则会返回NSRangeException异常12id lastObject = [array lastObject];id firstObject = [array firstObject]; 为了方便数组中数据量很大的情况下查找数据，苹果已经预先实现二分查找法来遍历数组，这样查询效率将大大提高12345678910NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];NSMutableArray *mutableArray = [NSMutableArray array];NSRange range = NSMakeRange(0, 5);NSInteger index = [array indexOfObject:@0 inSortedRange:range options:NSBinarySearchingInsertionIndex usingComparator:^NSComparisonResult(id obj1, id obj2) &#123; if (obj1 &lt; obj2) &#123; return NSOrderedAscending; &#125; return NSOrderedDescending;&#125;];id object = mutableArray[index]; 4.排序有很多方法可以对数组进行排序，如果数组中存放的是字符串对象，可以使用sortedArrayUsingSelector:方法进行排序12NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;];NSArray *newArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)]; 如果数组存放的是数字，可以使用compare:方法进行排序12NSArray *array = @[@4, @0, @8, @9, @11];NSArray *newArray = [array sortedArrayUsingSelector:@selector(compare:)]; 可是使用reverseObjectEnumerator.allObjects获得一个数组的逆序排列12NSArray *array = @[@4, @0, @8, @9, @11];NSArray *newArray = array.reverseObjectEnumerator.allObjects; 5.枚举从一个数组过滤一些元素，组成另一个数组使我们经常遇到的一个场景，同样Objc提供了很多方法可以实现1.快速枚举 NSFastEnumeration(for in)使用快速枚举在数组数据量较大的情况下效率会比传统的for循环提高很多，而且快速枚举代码的可读性也更高1234567NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];NSMutableArray *newArray = [NSMutableArray array];for (NSString *godName in array) &#123; if ([godName containsString:@&quot;l&quot;]) &#123; [newArray addObject:godName]; &#125; &#125;NSLog(@&quot;%@&quot;,newArray); 2.使用indexesOfObjectsWithOptions方法当数据量很大的情况下，使用indexesOfObjectsWithOptions方法的NSEnumerationConcurrent参数可以开启同步执行，但这也只是在数据量很大的情况下，当数据量较少时候因为需要额外的线程管理效率会变得更低一些123456789101112NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];NSIndexSet *indexSet = [array indexesOfObjectsWithOptions:NSEnumerationConcurrent passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) &#123; if ([obj isKindOfClass:[NSString class]]) &#123; NSString *godName = obj; if ([godName containsString:@&quot;l&quot;]) &#123; return obj; &#125; &#125; return nil; &#125;];NSArray *newArray = [array objectsAtIndexes:indexSet];NSLog(@&quot;%@&quot;,newArray);]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS常用设计模式]]></title>
    <url>%2F2015%2F08%2F12%2FiOS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[所有的iPhone应用程序都是基于UIKit框架构建而成的，所以它们在本质上具有相同的核心架构。 UIKit框架的设计模式 结合了很多在Mac OS X Cocoa应用程序中使用的设计模式，理解这些设计模式对于创建iPhone程序是很关键的。 1.模型-视图-控制器模式 MVC模式模型-视图-控制器模式(model-view-controller)简称MVC模式，它将您的代码独立分割为几个部分。模型部分定义应用程序的数据引擎，负责维护数据的完整性；视图定义应用程序的用户界面；控制器则充当模型和视图的桥梁，负责实现数据和现实的更新。 2.目标-动作控件通过目标-动作的模式将用户的交互通知您的应用程序，当用户以预先定义好的动作（比如点击一个按钮）进行交互时，空间就会将消息（动作）发送给您制定的对象（目标）。接收到动作消息后，目标对象就会以恰当的方式相应（比如按动按钮的时候刷新应用程序的状态）。 3.单例模式单例模式确保一个给定类只有一个实例出现，这个实例有一个全局的访问点，它通常使用懒加载的时候在第一次使用的时候再取加载注意：苹果使用了大量的单例模式，我们用到的[UIAppliacation shareapplication],[UIScreen mainscreen],[NSUserDefaults standardUserDefaults] 等返回的都是一个单例对象。在一些情况下使用单例模式会是非常合理的，比如你需要一个全局配置处理类，使用单例模式就会很好的实现。使用GCD的方式可以很容易实现一个单例模式 1234567891011+(Singelton)shareInstance&#123; // 1 static Singelton *st; // 2 static dispatch_once_t onceToken; // 3 dispatch_once(&amp;onceToken,^&#123; st =[[Singelton alloc]init]; &#125;); return st;&#125; 在这段代码中有三个需要注意的地方： 声明一个static静态变量保存实例变量，确保它在类中的全局可用性。 声明一个static静态dispath_once_t，确保初始化代码只执行一次 使用 Grand Center Dispatch (GCD)执行Singelton变量block，正式单例模式的关键，一旦类被初始化，初始化器就不会再被调用下次再调用shareInstance的时候，dispatch_once块中得代码将不会执行（因为他已经被执行了一次），你将得到已经初始化好的类 4.代理设计模式代理设计模式 一个对象提供机会对另一个对象发生变化时候做出反应。代理模式基本思想：两个对象协同解决问题，通常用于对象之间的通信 Cocoa 框架中同样运用了大量的代理模式，每个UI控件后边都声明了一个id类型的delegate或是datasource，比如说最常用到的UITableView 控件头文件中声明了：12@property (notamatic, assign)id &lt;UITableViewDataSource&gt; datasource; @property (notamatic, assign)id &lt;UITableViewDelegate&gt; delegate; 即这个代理要遵循某一个协议。]]></content>
  </entry>
</search>
