<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS多线程 --- pthread和NSThread]]></title>
    <url>%2F2019%2F12%2F04%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20pthread%E5%92%8CNSThread%2F</url>
    <content type="text"><![CDATA[多线程，是实现多个线程并发执行的技术，对于单核CPU来说，虽然在硬件的限制下同时只能执行一个线程，但是操作系统可以快速的在不同线程之间切换，在很小的切换时间下，来给用户造成一种同时运行多个线程的假象，而对于多核CPU，因为有硬件的支持而能够在同一时间同时运行多个线程iOS中有以下几种线程方案 Pthread NSThread GCD NSOperationQueue PthreadPthread是一套通用的多线程方案，可以在类Unix操作系统（如Unix，Linux，Mac OS)等系统使用，它使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，在开发中几乎不会直接使用它。 使用pthread创建一个线程 1234567891011121314//声明一个thread变量pthread_t thread;//创建并开启thread，执行test函数pthread_create(&amp;thread, NULL, test, NULL);//设置该线程的状态为detach，使该线程执行结束后自动释放所有资源pthread_detach(thread);NSLog(@&quot;Current Thread1:%@&quot;, [NSThread currentThread]); //打印结果：Current Thread1:&lt;NSThread: 0x60000360acc0&gt;&#123;number = 1, name = main&#125;void *test(void *param)&#123; NSLog(@&quot;Current Thread12:%@&quot;, [NSThread currentThread]);//打印结果：Current Thread1:&lt;NSThread: 0x60000361ad00&gt;&#123;number = 6, name = (null)&#125; return NULL;&#125; 打印结果：122019-12-04 21:37:25.502129+0800 Thread[2601:163643] Current Thread2:&lt;NSThread: 0x600002aa5040&gt;&#123;number = 6, name = (null)&#125;2019-12-04 21:37:25.503243+0800 Thread[2601:163558] Current Thread1:&lt;NSThread: 0x600002ad5040&gt;&#123;number = 1, name = main&#125; 可以看到在pthread中通过pthread_create函数来创建线程，pthread_create(&amp;thread, NULL, test, NULL)有四个参数,各项参数含义如下： 第一个参数：指向线程（标识符）的指针第二个参数：用来设置线程属性 ，通常设置为NULL第三个参数：线程运行的函数地址第四个参数：运行函数的参数其中第一、二个参数比较简单，这里再额外介绍一下第三四个参数，第三个参数”线程属性“是一个pthread_attr_t类型的结构体，这个结构体如下：123456789101112typedef struct &#123; int detachstate; //线程的分离状态 int schedpolicy; //线程调度策略 struct sched_param schedparam; //线程的调度参数 int inheritsched; //线程的继承性 int scope; //线程的作用域 size_t guardsize; //线程栈末尾的警戒缓冲区大小 int stackaddr_set; void *stackaddr; //线程栈的位置 size_t stacksize; //线程栈的大小&#125;pthread_attr_t; 要使用pthread_attr_t我们需要对它进行初始化，使用后还要去初始化pthread_attr_t初始化函数：1pthread_attr_init() pthread_attr_t去初始化函数：1pthread_attr_destory() pthread_attr_init之后，pthread_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值 如果想修改这些默认值，pthread_attr_t的每一个属性都有相应的函数对其进行查看和修改 比如修改分离状态可以用：12int pthread_attr_getdetachstate(const pthread_attr_t * attr, int * detachstate);int pthread_attr_setdetachstate(pthread_attr_t * attr, int detachstate); 设置的时候可以有两种选择： .detachstate参数为：PTHREAD_CREATE_DETACHED 分离状态启动 .detachstate参数为：PTHREAD_CREATE_JOINABLE 正常启动线程 线程的继承性：12int pthread_attr_getinheritsched(const pthread_attr_t *attr,int *inheritsched);int pthread_attr_setinheritsched(pthread_attr_t *attr,int inheritsched); 参数支持： PTHREAD_INHERIT_SCHED： 新的线程继承创建线程的策略和参数 PTHREAD_EXPLICIT_SCHED：新的线程继承策略和参数来自于 schedpolicy和schedparam属性中显式 设置的调度信息 pthread_attr_t的其他属性都有相应的函数来修改，这里就不一一介绍了，感兴趣的同学可以在stackoverflow的when pthread_attr_t is not NULL?问题中了解到更多信息 第四个参数：运行函数传递的参数，当传递单个参数时，可以直接定义一个变量传递给线程函数，当需要传递多个参数时候，就需要创建一个结构体来包含所有的参数，然后再传入线程函数： 传单个参数的情况 12345678910//定义一个函数void *test(void *param)&#123; NSLog(@&quot;test:%d&quot;, *(int *)param); return NULL;&#125;//声明变量，创建线程，调用函数传递参数int i = 100;pthread_create(&amp;thread, NULL, test, &amp;i);pthread_detach(thread); 传多个参数： 1234567891011121314151617181920//定义一个结构体struct parameters&#123; int size; int count;&#125;;//定义函数void *test(void *param)&#123; struct paramaters *args; args = (struct paramaters *)param; NSLog(@&quot;test:size:%d， count:%d&quot;, args-&gt;size, args-&gt;count); return NULL;&#125;//声明结构体变量，结构体赋值，创建线程，调用函数传递参数struct paramaters args;args.size = 100;args.count = 300;pthread_create(&amp;thread, NULL, test, &amp;args);pthread_detach(thread); 除了pthread_create，Pthread 还有以下相关函数： pthread_exit() 终止当前线程 pthread_cancel() 中断另外一个线程的运行 pthread_join() 阻塞当前的线程，直到另外一个线程运行结束 pthread_attr_init() 初始化线程的属性 pthread_attr_setdetachstate() 设置脱离状态的属性（决定这个线程在终止时是否可以被结合） pthread_attr_getdetachstate() 获取脱离状态的属性 pthread_attr_destroy() 删除线程的属性 pthread_kill() 向线程发送一个信号 我们通常并不会直接使用pthread来管理线程，所以对pthread不再做过多的介绍 NSThreadNSThread和pthread都是对内核 mach kernal的mach thread的封装，不同的是NSThread是由苹果官方提供的，可以直接操作线程对象，使用起来比pthread更加易用，不过仍需要自己管理生命周期、同步、加锁的问题 创建线程：1234567//先创建线程，再启动线程NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(sailTickets) object:nil];[thread start];//先创建线程后自动启动线程[NSThread detachNewThreadSelector:@selector(test) toTarget:self withObject:nil];//隐式创建并启动线程[self performSelectorInBackground:@selector(test) withObject:nil]; 线程相关方法123456789101112// 获得主线程+ (NSThread *)mainThread; // 判断是否为主线程(对象方法)- (BOOL)isMainThread;// 判断是否为主线程(类方法)+ (BOOL)isMainThread; // 获得当前线程NSThread *current = [NSThread currentThread];// 线程的名字——setter方法- (void)setName:(NSString *)n; // 线程的名字——getter方法- (NSString *)name; 线程状态控制方法1234- (void)start;// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态+ (void)sleepUntilDate:(NSDate *)date;// 线程进入阻塞状态+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 线程进入阻塞状态+ (void)exit;// 线程进入死亡状态 线程之间的通信在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法 123456789101112// 在主线程上执行操作- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray&lt;NSString *&gt; *)array;// 在指定线程上执行操作- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; 线程的五个状态New Runnabled Running Blocked Dead New:1NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadDemo) object:nil]; Runnabled：1[thread start]; RunningCPU负责调度可调度线程池中的处于就绪状态的线程，线程在执行结束之前，状态可能在就绪和运行之间来回的切换，就绪和运行之间的状态切换由CPU来完成，我们无法干涉 阻塞正在运行的线程，当满足某个条件时，可以用休眠或者锁来阻塞线程的执行123456//sleepForTimeInterval:休眠指定时长[NSThread sleepForTimeInterval:1.0];//sleepUntilDate:休眠到指定日期[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]];//互斥锁@synchronized(self) Dead线程正常死亡：线程执行结束线程非正常死亡：线程突然崩溃/当满足某个条件后，在线程内部强制退出，调用exit方法 关于exit需要注意的地方：不能在主线程中调用该方法.会使主线程退出.当当前线程死亡之后,这个线程中的代码都不会被执行.在调用此方法之前一定要注意释放之前由C语言框架创建的对象 线程状态的转换当我们创建了一个线程，执行start方法后，系统把线程放入可调度线程池中，此时线程进入就绪（Runnabled）状态如果CPU调度当前线程，则当前线程进入运行状态，当CPU调度其他线程，则当前线程回到就绪状态如果系统在运行当前线程时候调用了sleep方法/等待同步锁，则当前线程进入阻塞状态，等到sleep到时/得到同步锁，则回到就绪状态如果系统在运行当前线程对象的时候线程任务执行完毕/异常强制退出，则当前线程对象进入死亡状态 线程常驻在一些场景中需要用到常驻线程，要使线程常驻就需要用到RunLoop，每个线程都有一个RunLoop这是默认没有开启，RunLoop的开启就意味着线程的常驻，比如主线程 下边这段代码来自AFNetworking1234567891011121314151617+ (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125;+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; 这里的_networkRequestThread就属于常驻线程，可以看到要想创建一个常驻线程，只要以下几步：1.创建一个全局的thread变量1@property (nonatomic, strong) NSThread *networkThread; 2.初始化线程并启动12self.networkThread = [[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];[self.networkThread start]; 3.在线程中开启RunLoop，子线程中的RunLoop是默认关闭的12345- (void)run&#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]); [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run];&#125; 现在networkThread已经实现了常驻，当需要使用它的时候可以这么调用4.利用常驻线程处理任务1[self performSelector:@selector(action) onThread:self.networkThread withObject:nil waitUntilDone:NO ];]]></content>
  </entry>
  <entry>
    <title><![CDATA[栈的最佳实践 - 打造一个逆波兰计算器]]></title>
    <url>%2F2019%2F04%2F23%2F%E6%A0%88%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[栈的介绍栈的应用很多，可以检查程序中的符号是否都成对的出现，每一个右括号都应该有一个对应的左括号，可以用栈来实现进制的转换，当然还有今天的主题，利用栈来实现一个逆波兰计算器 逆波兰表达式逆波兰表达式（Reverse Polish Notation 简称RPN），又称为后缀表达式，作为比较，我们常用的中序表达式表示方法是操作符位于操作数中间，比如 1 + 2，这里操作符+位于操作数1和2中间，而后缀表达式的表示方法是操作符位于两个操作数中间，比如1 2 +，这里的操作符+位于两个操作数1 2后边。总结来说RPN的特点就是表达式中各个运算是按运算符出现的顺序进行的，故无须使用括号来指示运算顺序 下边给出一些表达式的两种表示方法1231 + 2 1 2 +1 + 2 * 3 1 2 3 * +1 - ( 3 + 1 ) 1 3 1 + - 从上面的例子可以看出： 在两种表示中，运算对象出现的顺序相同； 在后缀表示中，运算符按实际计算顺序从左到右排列，且每一运算符总是跟在其运算对象之后。 逆波兰表达示的优势就在于我们只需要两种简单的操作入栈和出栈，就可以实现简单表达式的运算 中序表达式转换为逆波兰表达式首先需要分配两个栈，一个是用来存储临时操作符的栈S1，还有一个用来存储逆波兰表达式的栈S2 从中序表达式的左端取字符，逐一执行以下操作 若取出的字符是操作数，直接将操作数送入S2栈 若取出的字符是运算符，则将该运算符与S1栈栈顶元素比较，如果该运算符优先级大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，则将该运算符送入S1栈。 若取出的字符是“（”，则直接送入S1栈栈顶。 若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个出栈，依次送入S2栈，此时抛弃“（”。 重复上面的1~4步，直至处理完所有的输入字符 若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。完成以上步骤，S2栈便为逆波兰式输出结果。不过不要忘记S2栈要做一下逆序处理 计算的逻辑]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS中Active与JS的交互]]></title>
    <url>%2F2019%2F04%2F22%2FiOS%E4%B8%ADActive%E4%B8%8EJS%E7%9A%84%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[iOS原生代码和HTML中的JS进行交互有以下几种方法 拦截URL 使用JavaScriptCore 使用WKScriptMessageBridge 使用开源框架WebViewJavascriptBridge 这几种方法各有特点，其中 方法1、2、4可以进行iOS 、Android跨平台操作 方法3只支持iOS平台，如果想要使用1套js支持iOS Android两端，那么使用使用WKScriptMessageBridge可以排除在外 拦截URLjs调用原生代码拦截url使用比较简单，和后端同事协商好URL协议，比如jsaction://openAlbum表示打开相册实现UIWebView的代理方法：shouldStartLoadWithRequest:navigationType，在方法中对url进行拦截判断1234567- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123;if ([request.URL.absoluteString hasPrefix:@&quot;jsaction://openAlbum//调用原生扫描二维码return NO;&#125;return YES;&#125; HTML代码：1&lt;a href=&quot;jsaction://openAlbum&quot;&gt;扫一扫(拦截url)&lt;/a&gt; 原生调用js代码：在打开相册后如果想反馈给HTML页面，可以执行UIWebView的stringByEvaluatingJavaScriptFromString:方法，或者WKWebView的 evaluateJavaScript:completionHandler:方法。1[self.webView stringByEvaluatingJavaScriptFromString:@&quot;openResult(‘成功打开相册&apos;)”]; 拦截URL使用简单，js端只要约定好url协议就可以，但是缺点同样明显，代理方法中讲充斥大量判断URL的硬编码，约定好的连接都是写死的，而且通信是单向的，不支持return和callBack，只能做send操作，不能做get操作，所以拦截URL适用于业务相对简单的需求。 使用JavaScriptCoreJavaScriptCore只支持UIWebView，支持系统版本为iOS7+通过 JSContext 获取 UIWebView 的 JS 执行上下文。然后通过这个上下文，进行 OC &amp; JS 的双端交互。 js调用原生你需要创建一个对象继承自NSObject，并遵循JSExport协议，代理的方法和js的方法保持一致，.m中实现代理方法12345678910111213141516//JSObject.h#import &lt;Foundation/Foundation.h&gt;#import &lt;JavaScriptCore/JavaScriptCore.h&gt;@protocol JSObjectDelegate &lt;JSExport&gt;-(void)openAlbum:(NSString *)message;@end@interface JSObject : NSObject&lt;JSObjectDelegate&gt;@property(nonatomic,weak) id&lt;AppJSObjectDelegate&gt; delegate;@end//JSObject.m#import &quot;AppJSObject.h&quot;@implementation JSObject-(void)openAlbum:(NSString *)message&#123;[self.delegate openAlbum:message];&#125;@end 123456789JS代码：&lt;script type=&quot;text/javascript&quot;&gt;function openAlbum()&#123;app.scan(‘openResult&apos;);&#125;function openResult(result)&#123;document.getElementById(&quot;result&quot;).innerHTML = ‘打开结果：&apos; + result; &#125;&lt;/script&gt; 在UIWebView加载完成的代理中把SObject实例对象类注入到JS中，那么在js中调用方法就会调用到原生JSObject实例对象中对应的方法了。1234567-(void)webViewDidFinishLoad:(UIWebView *)webView&#123;JSContext *context=[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];JSObject *jsObject = [JSObject new];jsObject.delegate = self;context[@&quot;app&quot;] = jsObject;&#125; 原生调用js123JSContext *context=[_mainWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];NSString *alertJS= [NSString stringWithFormat:@&quot;%@(&apos;%@&apos;)&quot;,_photoMethod,fileUrl];[context evaluateScript:alertJS]; JavaScriptCore 是跨平台的，你不需要在代理方法中添加大量的硬编码，支持双向的return，js调用原生方法可以拿到return，native调用js也可以拿到return，缺点就是JavaScriptCore只支持UIWebView不支持WKWebView，而UIWebView在内存优化，加载速度上都存在一些问题，所以使用JavaScriptCore的话只能舍弃WKWebView，而且只支持return，不支持callback，所以在异步调用的时候拿不动返回值。 WKScriptMessageBridge我们之前说过，WKScriptMessageBridge无法做到跨平台，所以这里做一个简单介绍：通过 userContentController 把需要观察的 JS 执行函数注册起来。然后通过一个协议方法，将所有注册过的 JS 函数执行的参数传递到此协议方法中。初始化WKWebView时，调用addScriptMessageHandler:name:方法，name为js中的方法名，如openAlbum:1234567- (void)setupWKWebView&#123;WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];configuration.userContentController = [[WKUserContentController alloc] init];[configuration.userContentController addScriptMessageHandler:self name:@&quot;openAlbum&quot;];WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];webView.UIDelegate = self;&#125; js代码1window.webkit.messageHandlers.openAlbum.postMessage() 实现WKScriptMessageHandler代理方法，当js调用openAlbum方法时，会回调此代理方法：12345- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;if ([message.name isEqualToString:@&quot;openAlbum&quot;]) &#123;//调用原生扫码&#125;&#125; WebViewJavascriptBridgeWebViewJavascriptBridge是github上的开源库，用于UIWebView和WKWebView中原生代码和JS的交互，另外iOS和Android的WebViewJavascriptBridge在github上不是一个地址，但是实现思路和原理都是一样的，所以可以做到跨平台使用 实现原理把 原生 的方法注册到桥梁中，让 JS 去调用。把 JS 的方法注册在桥梁中，让 原生代码 去调用。 1.install JSBridgepod ‘WebViewJavascriptBridge’, ‘~&gt; 6.0’ 2.导出头文件1#import &lt;WKWebViewJavascriptBridge.h&gt; 3.初始化WebView和JSBridge12345678WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];WKUserContentController *userController = [[WKUserContentController alloc] init];configuration.userContentController = userController;_mainWebView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, KMainWidth, KMainHeight) configuration:configuration];NSString *path = [[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:@&quot;index.html&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL fileURLWithPath:path]];[_mainWebView loadRequest: request];self.bridge = [WKWebViewJavascriptBridge bridgeForWebView:self.mainWebView]; 4.在js文件中加入以下两个初始化函数1234567891011121314function setupWebViewJavascriptBridge(callback) &#123;if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement(&apos;iframe&apos;); WVJBIframe.style.display = &apos;none&apos;; // 不显示WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;setupWebViewJavascriptBridge(function(bridge)&#123;&#125;); 接下来我们描述一个场景 1.HTML中加一个按钮，点击调用原生代码 ，随机修改一个colorView的背景颜色2.原生页面添加一个按钮，点击调用js代码，用来修改HTML页面颜色 在原生代码中注册一个修改colorView背景颜色的block1234[self.bridge registerHandler:@&quot;colorClick&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;self.colorView.backgroundColor = [UIColor colorWithRed:arc4random_uniform(256) / 255.0 green:arc4random_uniform(256) / 255.0 blue:arc4random_uniform(256) / 255.0 alpha:1.0];responseCallback(@&quot;颜色修改完毕!&quot;);&#125;]; 在js文件里找到button的点击事件，添加以下代码1234WebViewJavascriptBridge.callHandler(&apos;colorClick&apos;,function(dataFromOC) &#123;alert(&quot;JS 调用了 OC 注册的 colorClick 方法&quot;);document.getElementById(&quot;returnValue&quot;).value = dataFromOC;&#125;) 此时我们就完成了HTML中点击按钮，修改原生代码中colorView的背景颜色，接下来继续在JS中添加一个function 用来修改body的背景颜色123456setupWebViewJavascriptBridge(function(bridge)&#123;bridge.registerHandler(&apos;changeBGColor&apos;,function(data,responseCallback)&#123;document.body.style.backgroundColor = &quot;orange&quot;;document.getElementById(&quot;returnValue&quot;).value = data;&#125;);&#125;); 然后在原生页面的button点击事件中添加以下代码1[self.bridge callHandler:@&quot;changeBGColor&quot; data:@“修改body背景颜色为橙色”]; 现在我们就完成从js调用原生代码修改colorview的背景颜色，原生页面的button点击时修改了HTML的背景颜色。关于内存泄漏在页面退出时需要删除在JSBridge中注入的block，否则可能会导致页面无法释放，造成内存泄漏的问题1234- (void)viewWillDisappear:(BOOL)animated&#123;[super viewWillDisappear:animated];[self.bridge removeHandler:@&quot;colorClick&quot;];&#125; 关于传参在OC和JS相互调用时候支持传递参数和添加回调 OC调用JS12345[self.bridg callHandler:@&quot;changeBGColor&quot;];[self.bridg callHandler:@&quot;changeBGColor&quot; data:@&quot;修改body背景颜色为橙色&quot;];[self.bridg callHandler:@&quot;changeBGColor&quot; data:@&quot;传递给 JS 的参数&quot; responseCallback:^(id responseData) &#123;NSLog(@&quot;JS 的返回值: %@&quot;,responseData);&#125;]; #####JS调用OC123456WebViewJavascriptBridge.callHandler(&apos;scanClick&apos;);WebViewJavascriptBridge.callHandler(&apos;scanClick&apos;,&quot;JS 参数&quot;);WebViewJavascriptBridge.callHandler(&apos;scanClick&apos;,&#123;data : &quot;这是 JS 传递到 OC 的扫描数据&quot;&#125;,function(dataFromOC)&#123;alert(&quot;JS 调用了 OC 的扫描方法!&quot;);document.getElementById(&quot;returnValue&quot;).value = dataFromOC;&#125;); 到这里WebViewJavascriptBridge就介绍完了，可以看到使用起来也很简单，你可以到WebViewJavascriptBridge的github主页上查看更多的信息。 WebViewJavascriptBridge虽然是一个三方库，但是已经是一个很成熟原生与JS交互的解决方案，在他的主页上可以看到Facbook也在使用它，WebViewJavascriptBridge特点是跨品台的，支持双向callback，可以异步回调，这也是我们项目组在用的方案]]></content>
  </entry>
  <entry>
    <title><![CDATA[weak-strong dance]]></title>
    <url>%2F2019%2F03%2F14%2Fweak-strong-dance%2F</url>
    <content type="text"><![CDATA[之所有要写这篇weak-strong-dance，是因为一个同事在聊天时表达了对这种写法困惑，在block中为什么要重新使用strong来修饰觉得没有必要，所以我写下这篇文章一来可以为他解惑，二来如果能帮助更多的同学理解weak-strong-dance就再好不过了 我们在使用RAC的时候经常会用到两个宏：@weakify(self)和@strongify(self)，这两个宏等价于 weak typeof(self) weakSelf = self; 和 strong typeof(self) strongSelf = weakSelf;，其实就是使用weak 和 strong来修饰当前的self对象。rac中用到了大量的block，在block中使用weak我们知道是为了防止循环引用，那么重新修饰成strong类型有什么作用呢？其实这里的weak和strong有一个美丽的名字：weak-strong dance 之前我们已经介绍了，在block中调用外部属性，为了避免循环引用，我们需要使用weak来修饰对象1234567891011@interface ViewController ()@property (nonatomic, copy) NSString *name;@end- (void)blockTest&#123;__weak typeof (self)weakSelf = self;void(^test)(void) = ^&#123;NSLog(@&quot;%@&quot;, weakSelf.name);&#125;;test();&#125; 在这里我们使用weak修饰了self，从而避免了循环引用的问题，但是使用weak是不是就能解决所有的问题呢？我们来看一下这个场景： 有两个ViewController， A 和 B 在A中点击按钮跳转到B B中设置两个定时任务1)定时任务1：3s的时候执行dismissViewController方法2)定时任务2：在任务1中设置6s后打印一个属性变量nameok，需求很简单，我们来看一下B VC的代码： 1234567891011121314151617181920212223242526@interface BViewController ()@property (nonatomic, copy) NSString *name;@end- (void)viewDidLoad&#123;[super viewDidLoad];self.view.backgroundColor = UIColor.whiteColor;self.name = @&quot;kate&quot;;__weak typeof(self) weakSelf = self;void (^test)(void) = ^&#123;[NSTimer scheduledTimerWithTimeInterval:3 repeats:NO block:^(NSTimer * _Nonnull timer) &#123;NSLog(@&quot;3s后&quot;);[weakSelf dismissViewControllerAnimated:YES completion:nil];[NSTimer scheduledTimerWithTimeInterval:6 repeats:NO block:^(NSTimer * _Nonnull timer) &#123;NSLog(@&quot;6s后&quot;);NSLog(@&quot;%@&quot;, weakSelf.name);&#125;];&#125;];&#125;;test();&#125;- (void)dealloc&#123;NSLog(@&quot;dealloc&quot;);&#125; 这段代码的执行结果是怎样的呢，大家可以先思考一下 运行结果：12342019-03-12 14:49:09.585089+0800 Block[3543:669240] 3s后2019-03-12 14:49:10.091926+0800 Block[3543:669240] dealloc2019-03-12 14:49:15.587989+0800 Block[3543:669240] 6s后2019-03-12 14:49:15.588211+0800 Block[3543:669240] (null) 可以看到，因为3s后B视图被销毁，使用weak修饰的self变成了nil，name自然就无法打印出来。 在这种情况下，我们使用上文中提到的weak-strong dance就可以完美解决： B视图修改后的代码：12345678910111213141516171819- (void)viewDidLoad&#123;[super viewDidLoad];self.view.backgroundColor = UIColor.whiteColor;self.name = @&quot;kate&quot;;__weak typeof(self) weakSelf = self;void (^test)(void) = ^&#123;[NSTimer scheduledTimerWithTimeInterval:3 repeats:NO block:^(NSTimer * _Nonnull timer) &#123;__strong typeof(self) strongSelf = weakSelf;NSLog(@&quot;3s后&quot;);[strongSelf dismissViewControllerAnimated:YES completion:nil];[NSTimer scheduledTimerWithTimeInterval:6 repeats:NO block:^(NSTimer * _Nonnull timer) &#123;NSLog(@&quot;6s后&quot;);NSLog(@&quot;%@&quot;, strongSelf.name);&#125;];&#125;];&#125;;test();&#125; 我们只是在timer内容使用strong重新修饰了weakSelf，然后使用strongSelf调用了相应的方法和属性执行结果：12342019-03-12 14:56:37.647339+0800 Block[3648:695087] 3s后2019-03-12 14:56:43.649361+0800 Block[3648:695087] 6s后2019-03-12 14:56:43.649604+0800 Block[3648:695087] kate2019-03-12 14:56:43.649789+0800 Block[3648:695087] dealloc 我们可以看到 name属性可以被打印出来了 看到这里，大家应该都认识了weak-storng dance，其实weak-storng dance主要解决的就是当block执行了一半时候被销毁，导致block内部出现的一些异常问题，比如视图被销毁，block在多线程中被销毁等情况，所以为了我们的代码更加健壮，请尽量使用weak-storng dance把。]]></content>
  </entry>
  <entry>
    <title><![CDATA[block]]></title>
    <url>%2F2019%2F03%2F14%2Fblock%2F</url>
    <content type="text"><![CDATA[说到Block，首先要介绍一下闭包（closure）,这是闭包在wiki)中的介绍： In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function[a] together with an environment.[1] The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.[b] Unlike a plain function, a closure allows the function to access those captured variables through the closure’s copies of their values or references, even when the function is invoked outside their scope. 闭包是一个函数或者是一个带有引用环境的函数，这个环境是一张存有这个函数中所有非本地变量的表 各种编程语言对闭包都有着自己的实现，c#有lambda，js有Closures，C++有函数对象等，而block就是苹果在OS X Snow Leopard和iOS4中开始引入的对C语言的扩展，从此广大开发者在执行数据的回调时又有了多一个选项。而且相对繁琐的delegate，block更加的灵活轻便 接下来我会从几个部分来介绍block block的内部实现 block的分类###block的内部实现在LLVM Block_private.h中可以找Block的定义：1234567891011121314151617/* Revised new layout. */struct Block_descriptor &#123;unsigned long int reserved;unsigned long int size;void (*copy)(void *dst, void *src);void (*dispose)(void *);&#125;;struct Block_layout &#123;void *isa;int flags;int reserved; void (*invoke)(void *, ...);struct Block_descriptor *descriptor;/* Imported variables. */&#125;; 可以看到Block存在着isa指针，我们知道所有实例对象的isa指针都指向了它的类对象，类对象的isa指向了原类对象。这也符合Apple对Block的描述，block也是一个对象，它可以像其他的对象一样存放在Array和Dictionary中 在上述结构体中，最重要的是invoke变量，从声明中可以看出，这是一个函数指针，指向了block的执行代码，block的执行代码就是一个匿名函数，在创建block的时候传递给了invoke变量 Block_layout结构体中包含了一个descriptor变量，而Block_descriptor比较重要的是copy和dispose函数，从字面上来看，copy用于捕获变量并且持有引用，dispose函数用于释放捕获的变量。block捕获的变量都会存放在结构体Block_layout的后面，对于对象存储的指针，在invoke函数执行之前全部读出。 block的分类block根据内存分步可以分为三类：NSGlobalBlock 全局的静态block，不会访问任何外部变量NSStackBlock 保存在栈上的block，当函数返回时会被销毁NSMallocBlock 保存在堆上的block，当引用计数为0时候会被销毁 你可以使用下边代码创建出这三种block1234567NSString *age = @&quot;11&quot;;NSLog(@&quot;%@&quot;, ^&#123;&#125;);NSLog(@&quot;%@&quot;, ^&#123;NSLog(@&quot;%@&quot;, age);&#125;);void(^block)(void) = ^&#123;NSLog(@&quot;%@&quot;, age);&#125;;NSLog(@&quot;%@&quot;, block); 打印结果：1232019-03-14 14:38:05.435150+0800 Block[5544:702103] &lt;__NSGlobalBlock__: 0x10f6ba180&gt;2019-03-14 14:38:05.435306+0800 Block[5544:702103] &lt;__NSStackBlock__: 0x7ffee05459f8&gt;2019-03-14 14:38:05.435437+0800 Block[5544:702103] &lt;__NSMallocBlock__: 0x60000270d5f0&gt; 接下来我们看一下这三类block在内部实现上的差别 NSGlobalBlock的内部实现这里我们要使用clang命令将Objective-C代码转换成C语言来查看block的源码具体实现1clang -rewrite-objc block.m 创建一个GlobalBlock.m文件，打印一个空的blog1NSLog(@&quot;%@&quot;, ^&#123;&#125;); 执行clang -rewrite-objc命令后，在目录下会多一个GlobalBlock.cpp文件，我们去除一些无用的代码，关键代码如下：12345678910111213141516171819struct __GlobalBlock__testBlock_block_impl_0 &#123;struct __block_impl impl;struct __GlobalBlock__testBlock_block_desc_0* Desc;__GlobalBlock__testBlock_block_impl_0(void *fp, struct __GlobalBlock__testBlock_block_desc_0 *desc, int flags=0) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void __GlobalBlock__testBlock_block_func_0(struct __GlobalBlock__testBlock_block_impl_0 *__cself) &#123;&#125;static struct __GlobalBlock__testBlock_block_desc_0 &#123;size_t reserved;size_t Block_size;&#125; __GlobalBlock__testBlock_block_desc_0_DATA = &#123; 0, sizeof(struct __GlobalBlock__testBlock_block_impl_0)&#125;;static void _I_GlobalBlock_testBlock(GlobalBlock * self, SEL _cmd) &#123;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_GlobalBlock_2850c5_mi_0, ((void (*)())&amp;__GlobalBlock__testBlock_block_impl_0((void *)__GlobalBlock__testBlock_block_func_0, &amp;__GlobalBlock__testBlock_block_desc_0_DATA)));&#125; 方法 GlobalBlocktestBlock_block_impl_0就是block的实现，我们可以看到 isa指向了 _NSConcreteStackBlock，这里的impl指向了main_block_func_0， main_block_func_0就是创建block时定义的一个函数。因为我们创建的block是空的，所以这里__main_block_func_0也是空的 NSStackBlock的内部实现创建一个StackBlock.m，添加上以下代码12NSString *age = @&quot;11&quot;;NSLog(@&quot;%@&quot;, ^&#123;NSLog(@&quot;%@&quot;, age);&#125;); clang后获取关键代码：1234567891011121314151617181920212223242526struct __StackGlobal__testBlock_block_impl_0 &#123;struct __block_impl impl;struct __StackGlobal__testBlock_block_desc_0* Desc;NSString *age;__StackGlobal__testBlock_block_impl_0(void *fp, struct __StackGlobal__testBlock_block_desc_0 *desc, NSString *_age, int flags=0) : age(_age) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void __StackGlobal__testBlock_block_func_0(struct __StackGlobal__testBlock_block_impl_0 *__cself) &#123;NSString *age = __cself-&gt;age; // bound by copyNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_StackGlobal_291f7c_mi_2, age);&#125;static void __StackGlobal__testBlock_block_copy_0(struct __StackGlobal__testBlock_block_impl_0*dst, struct __StackGlobal__testBlock_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;age, (void*)src-&gt;age, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static void __StackGlobal__testBlock_block_dispose_0(struct __StackGlobal__testBlock_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;age, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static struct __StackGlobal__testBlock_block_desc_0 &#123;size_t reserved;size_t Block_size;void (*copy)(struct __StackGlobal__testBlock_block_impl_0*, struct __StackGlobal__testBlock_block_impl_0*);void (*dispose)(struct __StackGlobal__testBlock_block_impl_0*);&#125; __StackGlobal__testBlock_block_desc_0_DATA = &#123; 0, sizeof(struct __StackGlobal__testBlock_block_impl_0), __StackGlobal__testBlock_block_copy_0, __StackGlobal__testBlock_block_dispose_0&#125;;static void _I_StackGlobal_testBlock(StackGlobal * self, SEL _cmd) &#123;NSString *age = (NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_StackGlobal_291f7c_mi_0;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_StackGlobal_291f7c_mi_1, ((void (*)())&amp;__StackGlobal__testBlock_block_impl_0((void *)__StackGlobal__testBlock_block_func_0, &amp;__StackGlobal__testBlock_block_desc_0_DATA, age, 570425344)));&#125; 在这里我们看到impl.isa指向了_NSConcreteStackBlock，StackGlobaltestBlock_block_impl_0中增加了一个变量age，在block中引用的age实际上在申明block时就被就被复制到了StackGlobaltestBlock_block_impl_0结构体中的变量age，心在我们就能够理解，在block内部修改变量age的内容，不会影响外部的实际变量age 在使用block时想要在block内部修改局部变量，需要使用__block来修饰局部变量，此时block的内部实现是怎样的呢修改StackBlock.h中代码如下：123456NSString *age = @&quot;11&quot;;__block NSInteger index = 1;^&#123;NSLog(@&quot;%@&quot;, age);index = 2;&#125;(); 重新执行clang,源码如下：12345678910111213141516171819202122232425struct __Block_byref_index_0 &#123;void *__isa;__Block_byref_index_0 *__forwarding;int __flags;int __size;NSInteger index;&#125;;struct __StackGlobal__testBlock_block_impl_0 &#123;struct __block_impl impl;struct __StackGlobal__testBlock_block_desc_0* Desc;NSString *age;__Block_byref_index_0 *index; // by ref__StackGlobal__testBlock_block_impl_0(void *fp, struct __StackGlobal__testBlock_block_desc_0 *desc, NSString *_age, __Block_byref_index_0 *_index, int flags=0) : age(_age), index(_index-&gt;__forwarding) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void __StackGlobal__testBlock_block_func_0(struct __StackGlobal__testBlock_block_impl_0 *__cself) &#123;__Block_byref_index_0 *index = __cself-&gt;index; // bound by refNSString *age = __cself-&gt;age; // bound by copyNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cy_k1991q191tvgck18lqhnqq7c0000gn_T_StackGlobal_274897_mi_1, age);(index-&gt;__forwarding-&gt;index) = 2;&#125; 我们可以看到多了一个Block_byref_index_0结构体，其中包含一个index变量， StackGlobal__testBlock_block_func_0中多了一个__Block_byref_index_0的指针，这样就可以完成修改外部变量 NSMallocBlock的内部实现NSMallocBlock类型的block在源码中无法体现出来，因为NSMallocBlock是在stackblock在执行copy后才会被拷贝到malloc上，我们可以看一下runtime.c的源码，在这里可以看到block是如何从stack拷贝到malloc的重点看一下_Block_copy_internal函数中这一段代码：123456789101112131415// Its a stack block. Make a copy.if (!isGC) &#123;struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);if (!result) return (void *)0;memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first// reset refcountresult-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK); // XXX not neededresult-&gt;flags |= BLOCK_NEEDS_FREE | 1;result-&gt;isa = _NSConcreteMallocBlock;if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;//printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);(*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup&#125;return result;&#125; 如果判断block位于stack中，则执行copy方法可以看到在这里讲isa指向了_NSConcreteMallocBlock。此时，位于stack上的block就被转成了NSMallocBlock类型的block 我们可以看到，苹果的网络请求API NSURLConnect还是用的delegate来实现回调，而到了NSURlSession，苹果更多的是换成了Block，更不要说RAC中遍布所有API中的block，所以只有你对Block有着足够深刻的理解，在使用这些框架时候才能更加的游刃有余，做到知其然知其所以然。]]></content>
  </entry>
  <entry>
    <title><![CDATA[pomera]]></title>
    <url>%2F2019%2F03%2F12%2Fpomera%2F</url>
    <content type="text"><![CDATA[Η Pomera τηρεί αυστηρά τους νόμους και τους κανονισμούς και ακολουθεί τις ακόλουθες αρχές προστασίας προσωπικών δεδομένων για να σας παρέχει ασφαλέστερες και πιο αξιόπιστες υπηρεσίες:1, ασφαλής και αξιόπιστη: η pomera δεν θα συλλέξει τα προσωπικά σας στοιχεία2, ανεξάρτητη επιλογή: σας παρέχουμε βολικές λειτουργίες λειτουργίας, χωρίς παραπλανητική λειτουργία3, προστατεύστε το μυστικό: προστατεύουμε αυστηρά το περιεχόμενο των αρχείων ανάγνωσής σας Η Pomera είναι μια απλή και ισχυρή κάμερα ομορφιάς στο iPhone. Διαθέτουμε μια ποικιλία φίλτρων ομορφιάς για να διαλέξετε, κάθε μια από τα οποία προσεγγίζεται προσεκτικά από τους μηχανικούς μας. Ταυτόχρονα, μπορείτε να προσθέσετε εικονογραφήσεις στις φωτογραφίες σας για να κάνετε τις φωτογραφίες σας πιο ενδιαφέρουσες και ενδιαφέρουσες.]]></content>
  </entry>
  <entry>
    <title><![CDATA[翻译：ReactiveCocoa for a better world]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%BF%BB%E8%AF%91%EF%BC%9AReactiveCocoa-for-a-better-world%2F</url>
    <content type="text"><![CDATA[ReactiveCocoa创造更美好的世界原文：ReactiveCocoa for a better world 首先说一下为什么要翻译这篇2012年的文章。ReactiveCocoa for a better world是由Josh Abernathy在2012年发表，那个时间刚好是ReactiveCocoa开源的时间，而作者Josh Abernathy正是这一开源框架的主要作者，在这篇文章中Josh Abernathy从多个角度为我们介绍了为什么要使用ReactiveCocoa以及ReactiveCocoa能为我们做什么，在这篇文章中你可能会看到一些其他介绍ReactiveCocoa文章的影子，或者更应该说是在一些其他的关于ReactiveCocoa文章中看到ReactiveCocoa for a better world的影子。因为它的影响太深了，在时隔多年重新看到它后我有了把它翻译成中文的想法。 原生App花费了大量的时间来等待和响应，我们等待用户在UI界面上做一些操作，等待网络请求返回响应，等待异步操作的完成，等待一些依赖数据发生改变，然后做出响应。 但是所有的这些事情-所有的这些等待和响应-通常都会有许多不同的处理方式，这让我们在使用统一的方法来推断他们，chain them，或者是完成它们来变得非常困难。其实，我们可以通过高级方法来做的更好。 这就为什么我们开源这个神奇的魔法： GitHub for Mac: :ReactiveCocoa RAC是一个组合和转换序列值得框架。 认真讲，他是什么？ 让我们来看一些干货，RAC给我们带来了很多非常酷的东西： 组合操作一些未来数据的能力 最小化的使用状态量和可变数据的能力 用一种方式定义行为和属性之间的联系 一个统一的，更高级的异步操作接口 在KVO之上封装的友好的API 这些功能看起来可能像是随机的，直到你了解到RAC可以处理这些包含了将要等待的一些新值和响应的所有事件。 最美妙的地方在于RAC是那个能够适应许多不同的，常见的场景。说了这么多，让我们来看看RAC实际上的样子 Examples RAC可以将遵循了KVO-compliant属性利用KVO(key-value observing)l来带来序列的值.举个例子，我们可以看到username属性的变化123[RACAble(self.username) subscribeNext:^(NSString *newName) &#123;NSLog(@&quot;%@&quot;, newName);&#125;]; That’s cool,但是如果只有这些，那它只是一个比KOV更友好的API，RAC最酷的地方在于我们可以组合序列来一表示一些复杂的行为。假设我们想要检查用户输入的一个特殊用户名，当用用户输入前三个值之内的时候：123456789[[[RACAble(self.username)distinctUntilChanged]take:3]filter:^(NSString *newUsername) &#123;return [newUsername isEqualToString:@&quot;joshaber&quot;];&#125;]subscribeNext:^(id _) &#123;NSLog(@&quot;Hi me!&quot;);&#125;]; 我们发现username发生了变化，使用filter过滤发生的变化，使用take取前三个发生变化的值，如果新值是joshaber,我们就打印一个“hi mi 所以呢？ 考虑一下，如果我们不使用RAC来完成这个操作，我们将不得不： 为username添加上KVO进行监听 添加一个属性来记住我们通过KVO监听到的发生变化的最后一个值 添加一个属性来记录我们接收到了多少个发生了变化的值 任何时间获取到发生变化的值得时候都要添加属性 对数据进行比较 还有其他的么？我们可以组合序列：12345678[[RACSignalcombineLatest:@[ RACAble(self.password), RACAble(self.passwordConfirmation) ]reduce:^(NSString *currentPassword, NSString *currentConfirmPassword) &#123;return [NSNumber numberWithBool:[currentConfirmPassword isEqualToString:currentPassword]];&#125;]subscribeNext:^(NSNumber *passwordsMatch) &#123;self.createEnabled = [passwordsMatch boolValue];&#125;]; 当任何时间password和passwordConfirmation发生变化的时候，我们组合这两个属性最后的值，然后判断这两个值是否符合我们的要求，最后返回一个BOOL。我们就可以通过这个BOOL结果来设置button是否可以点击 BindingsWe can adapt RAC to give us powerful bindings with conditions and transformations: 12345RAC(self, help) = [[RACObserve(self.helpLabel, text) filter:^(NSString *newHelp)&#123;return newHelp != nil;&#125;] map:^(NSString *newHelp)&#123;return [newHelp uppercaseString];&#125;] 绑定help label的值得到属性help上，当流出的新值不是nil，就将这个新值转换成小写。（因为用户总喜欢being YELLED AT）、 AsyncRAC同样非常适合做异步操作 举个例子，我们通过调用一个block来完成多次并发操作：12345[[RACSignalmerge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]]subscribeCompleted:^&#123;NSLog(@&quot;They&apos;re both done!&quot;);&#125;]; 或是链式调用异步操作：1234567891011[[[[clientloginUser]flattenMap:^(id _) &#123;return [client loadCachedMessages];&#125;]flattenMap:^(id _) &#123;return [client fetchMessages];&#125;]subscribeCompleted:^&#123;NSLog(@&quot;Fetched all messages.&quot;);&#125;]; 用户登录后，首先加载缓存的消息，然后获取远程的消息，然后打印“Fetched all messages” 我们也可以方便的讲执行的操作移动到background queue123456789101112[[[[[clientfetchUserWithUsername:@&quot;joshaber&quot;]deliverOn:[RACScheduler scheduler]]map:^(User *user) &#123;// this is on a background queuereturn [[NSImage alloc] initWithContentsOfURL:user.avatarURL];&#125;]deliverOn:RACScheduler.mainThreadScheduler]subscribeNext:^(NSImage *image) &#123;// now we&apos;re back on the main queueself.imageView.image = image;&#125;]; 或者可以更简单的处理潜在的竞争条件，比如，我们可以使用异步操作中通过结果来更新属性，但是除非这个属性在异步操作完成前没有发生变化1234[[[selfloadDefaultMessageInBackground]takeUntil:RACAble(self.message)]toProperty:@keypath(self.message) onObject:self]; How does it work?RAC从根本上来看是非常简单的，它是以信号的方式来流转数据。Until you reach turtles. Subscribers来订阅signals，Signals为它的订阅者发送 ’next’, ‘error’, ‘completed’事件，如果所有的事情都是signals来发送时间，那么关键的问题就编程了：这些事件会在什么时候被发送？ Creating Signals信号根据合适发送时间来定义自己的行为，我们可以通过+[RACSignal createSignal:]来创建自己的signal：123456RACSignal *helloWorld = [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;[subscriber sendNext:@&quot;Hello, &quot;];[subscriber sendNext:@&quot;world!&quot;];[subscriber sendCompleted];return nil;&#125;]; 当这个signal获取一个新的订阅者，+[RACSignal createSignal:]会通过这个block进行回调。这个新的订阅者是通过里边的block我们可以发送这个事件。在上边的例子中，我们创建了一个signal会发送一个“hello”和“world”,然后发送完成。 嵌套signal我们可以基于helloWorld signal来创建另一个signal：1234567891011RACSignal *joiner = [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;NSMutableArray *strings = [NSMutableArray array];return [helloWorld subscribeNext:^(NSString *x) &#123;[strings addObject:x];&#125; error:^(NSError *error) &#123;[subscriber sendError:error];&#125; completed:^&#123;[subscriber sendNext:[strings componentsJoinedByString:@&quot;&quot;]];[subscriber sendCompleted];&#125;];&#125;]; 现在我们有了一个joiner signal,当有订阅者订阅了joiner，它会定义我们的helloworld signal. 它从helloworld和helloword完成时候增加了所有数据的接收，它将所有接收到的string连接在一起，然后发送他们和完成 在这种方式，我们可以创建signal来表达一些复杂的行为。 RAC实现了一套operations来恰好的实现他们，他们通过使用一些默认的行为来获取一些source signal 和返回一个新的signal More infoReactiveCocoa可以用于MAC和iOS开发，可以查看README来获取更多的信息，然后来导出MAC demo project 来获得一些实际的例子 对于.NET 开发者，所有这些听起来会很熟悉， ReactiveCocoa实际上是一个Objective-c版本的.NET Reactive Extensions)(Rx). 大多数的Rx规则应用于RAC上是非常合适的，这里是一些非常好的Rx资源： Reactive Extensions MSDN entry) Reactive Extensions for .NET Introduction Rx – Channel 9 videos Reactive Extensions wiki 101 Rx Samples Programming Reactive Extensions and LINQ (Co-authored by our own Paul Betts!)]]></content>
  </entry>
  <entry>
    <title><![CDATA[fastlane]]></title>
    <url>%2F2019%2F02%2F25%2Ffastlane%2F</url>
    <content type="text"><![CDATA[##使用背景早些时候我一直使用python执行脚本来完成项目的持续集成，在Apple发布Xcode9的时候脚本进行了更新，部分脚本被废弃，在那时候我转移到fastlane阵营，原因很简单，fastlane使用更简单，更方便，我不再需要因为苹果对脚本的更新来被迫修改我的方案。 ##fastlane介绍fastlane是一款持续集成工具，它的功能强大，使用简单，可以帮助我们处理一些费时的工作，比如生成截屏、处理配置文件、编译App、上传测试分发平台等。 fastlane is a tool for iOS and Android developers to automate tedious tasks like generating screenshots, dealing with provisioning profiles, and releasing your application. ###开始使用fastlance ####安装fastlance安装Xcode command line tool的最新版本1xcode-select —install 使用工具安装fastlance12345#使用gem安装（确保你已经安装了ruby）sudo gem install fastlane -NV#或者使用Homebrew安装（确保已经安装了Homebrew）brew cask install fastlane ####配置fastlane在terminal中进入你的项目目录，执行以下代码：1fastlane init 接下来会根据你在安装时候的不同选择来创建不同的文件 screenshots TestFlight AppStore Manual这里选择4.Manual就好了，其他的功能后续也可以在配置文件中手动添加其中最需要注意的文件是fastlane/Fastfile，其中包含了你将要操作的所有信息 ####接下来要怎么做？fastlane创建了所有的必要文件给我们，现在你可以通过配置这些文件进行持续化集成 ###使用fastlane部署测试项目 ####编译fastlane 使用一个叫build_app的action来编译app，只要在Fastfile中加入下边代码：123lane :beta dobuild_app(scheme: &quot;MyApp&quot;)end 还可以在编译的时候加入其他的选项12345ane :beta dobuild_app(scheme: &quot;MyApp&quot;,workspace: &quot;Example.xcworkspace&quot;,include_bitcode: true)end ####上传app在编译完成后可以上传到你选择的分发测试平台，在fastlane你可以很简单的做到这个工作，甚至不需要做额外的工作就可以同时上传多个平台你可以选择上传的TestFlight，蒲公英，Fir，我们这里以蒲公英来举例：在这里你可以找到蒲公英的上传文档，你需要执行以下代码安装蒲公英插件···fastlane add_plugin pgyer修改Fastfile，在build_app后添加蒲公英代码1234lane :beta dobuild_app(export_method: &quot;ad-hoc&quot;)pgyer(api_key: &quot;7f15xxxxxxxxxxxxxxxxxx141&quot;, user_key: &quot;4a5bcxxxxxxxxxxxxxxx3a9e&quot;)end 做完这些配置后，你就可以通过fastlane来打包App，并自动上传到蒲公英，执行1fastlane beta， 你可以打开蒲公英，查看蒲公英提供的更多配置，比如添加密码，添加更新描述等。 接下来我会提供一个我正在用的Fastfile为大家提供参考12345678910111213141516default_platform(:ios)platform :ios dolane :test do#添加版本更新描述puts &quot;请输入版本描述：&quot;#获取输入的描述desc = STDIN.gets#依次配置workspagce，scheme，build configuration，和export_methodbuild_app(workspace: &quot;ProjectsName.xcworkspace&quot;, scheme: &quot;ProjectsName&quot;, configuration: &quot;Debug&quot;,export_method: &quot;development&quot;)#配置蒲公英的api_key,user_key,和输入的版本更新描述pgyer(api_key: &quot;59aa772ac06fe663xxxxxxxxxxxxxxx&quot;, user_key: &quot;0b18ced68eb3cc7xxxxxxxxxxxxxxxxxx&quot;, update_description: &quot;#&#123;desc&#125;&quot;)endend ###总结App的编译、打包、上传无趣又费时，使用fastlane可以提升效率，又可以节省我们的时间，不需要为了后续的操作一直盯着电脑。fastlane使用比较方便，这里我只是做一个简单的介绍，当然fastlane还提供了更多的功能，你可以在fastlane主页和fastlane github中找到更多的详细配置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Reactivecocoa全解析 2.常用操作和高阶函数]]></title>
    <url>%2F2019%2F02%2F18%2F2-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[RAC现在分了两部分，ReactiveCocoaObjc和ReactiveCocoaSwift,本文介绍的均是 ReactiveCocoaObjc 2.5.0 版本的内容. RAC的核心是信号源（RACStream），在RAC中，信号源代表随着时间而改变的流值，订阅者通过订阅信号来获取这些值，RACStream是一个抽象类，我们用到的最多的是它的之类 RACSignal和RACSequence，以下代码和示例使用的ReactiveCocoa 2.5版本 介绍RAC的操作之前先介绍以下链式操作 链式操作： 用过Masonry的同学应该对链式操作不陌生 123456789[self.label mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.top.left.mas_equalTo(0);make.centerY.mas_equalTo(self.view);make.width.height.mas_greaterThanOrEqualTo(0);&#125;]; 这里的make.top.left.mas_equalTo(0); 就是一个链式操作，执行一个方法后的返回结果接着执行下一个方法，前边我们已经讲到RAC使用的是FPR编程思想，所以在RAC中你同样可以使用链式操作 我们修改一下上边的例子：12345678910111213[[RACObserve(self, username)filter:^(NSString *newName) &#123;return [newName hasPrefix:@&quot;j&quot;];&#125;]subscribeNext:^(NSString *newName) &#123;NSLog(@&quot;%@&quot;, newName);&#125;]; 订阅：subscribeNext 12345678910111213141516// When self.username changes, logs the new name to the console.//// RACObserve(self, username) creates a new RACSignal that sends the current// value of self.username, then the new value whenever it changes.// -subscribeNext: will execute the block whenever the signal sends a value.[RACObserve(self, username) subscribeNext:^(NSString *newName) &#123;NSLog(@&quot;%@&quot;, newName);&#125;]; 当username内容发生变化，就会打印出一个新的值。 RACObserve(TARGET, KEYPATH) 是RAC提供的一个宏，他可以创建一个新的signal，这里，我们通过subscribeNext方法对 signal进行订阅，当username内容发生变化时，就会在block中获取username的新值并进行打印 bind 对信号进行绑定，返回一个新的信号，它会订阅原信号的值，在bindingBlock中对原信号的值进行转换。 1234567891011121314151617181920212223242526272829303132333435363738394041RACSignal *orignSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1];[subscriber sendCompleted];return [RACDisposable disposableWithBlock:^&#123;NSLog(@&quot;orign signal dispose&quot;);&#125;];&#125;];RACSignal *newSignal = [orignSignal bind:^RACStreamBindBlock&#123;return ^(NSNumber *value, BOOL *stop)&#123;return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(value.integerValue * 2)];[subscriber sendCompleted];return [RACDisposable disposableWithBlock:^&#123;NSLog(@&quot;bind dispose&quot;);&#125;];&#125;];&#125;;&#125;];[newSignal subscribeNext:^(id x) &#123;NSLog(@&quot;newSignal value = %@&quot;, x);&#125;]; map:要完成对orign signal值得转换，使用map 和flattenMap是更简单的选择，这两个方法其实也是对bind方法的封装 1234567891011121314151617181920212223RACSignal *orignSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1];[subscriber sendCompleted];return [RACDisposable disposableWithBlock:^&#123;NSLog(@&quot;orign signal dispose&quot;);&#125;];&#125;];[[orignSignal map:^id(NSNumber *value) &#123;return @(value.integerValue * 2);&#125;]subscribeNext:^(id x) &#123;NSLog(@&quot;new value is %@&quot;, x);&#125;]; flattenMap 返回的是一个新的signal 1234567891011121314151617RACSignal *newSignal2 = [orignSignal flattenMap:^RACStream *(NSNumber * value) &#123;return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(value.integerValue * 2)];return nil;&#125;];&#125;];[newSignal2 subscribeNext:^(id x) &#123;NSLog(@&quot;new value2 is %@&quot;, x);&#125;]; filter:对seguence遍历后进行过滤，将不符合条件的数据进行过滤掉，返回一个新的sequence nameArray.rac_sequence是将array转换为sequence，sequence代表了一个不可变的序列，它可以被订阅者订阅，而且还可以跟signal很方便的进行转换 123456789NSArray *nameArray = @[@&quot;tom&quot;, @&quot;jerry&quot;, @&quot;tomas&quot;, @&quot;link&quot;];NSArray *resultArray = [nameArray.rac_sequence filter:^BOOL(NSString *name) &#123;return name.length &gt; 3;&#125;].array;NSLog(@&quot;%@&quot;, resultArray); combineLatest 使用一个signal数组，当数组中的任意一个signal值发生变化时，就在block中对所有signal最后一个值进行处理，最后返回一个新的signal。 12345self.validLoginSignal = [[RACSignal combineLatest:@[RACObserve(self, username), RACObserve(self, password)] reduce:^(NSString *username, NSString *password)&#123;return @(username.isExist &amp;&amp; password.isExist);&#125;] distinctUntilChanged]; zip 对多个信号的值进行压缩后创建一个RACTuples， zip将对每一个signal的值以配对的形式进行合并，比如signalA发送1和3，signal发送了2，那么合并后的Tuples包含了signal的1和signal的2。这里是zip和combineLatest最大的区别，在这里使用combineLatest会得到3和2，因为会重复利用signalB的旧值 123456789101112131415161718192021222324252627282930313233RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1];[subscriber sendNext:@3];[subscriber sendCompleted];return nil;&#125;];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2];[subscriber sendCompleted];return nil;&#125;];[[RACSignal zip:@[signalA, signalB]] subscribeNext:^(id x) &#123;NSLog(@&quot;zip %@&quot;, x); //==&gt;1，2&#125;];[[RACSignal combineLatest:@[signalA, signalB]] subscribeNext:^(id x) &#123;NSLog(@&quot;combineLatest: %@&quot;, x); //==&gt;3，2&#125;]; merge 对多个signal进行合并，会监听到任意一个signal值得变化，并返回这个signal最新的值，当所有的signal发送complete时候会发送complate，当任意一个signal发送error立刻就发送error 12345[[RACSignal merge:@[signalA, signalB]] subscribeNext:^(id x) &#123;NSLog(@&quot;x = %@&quot;, x);&#125;];]]></content>
  </entry>
  <entry>
    <title><![CDATA[Reactivecocoa全解析 1.FRP编程思想]]></title>
    <url>%2F2019%2F02%2F18%2F1-FRP%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[ReactiveCocoa全解析 1.FRP编程思想 ReactiveCocoa是我在开发工作中重度使用的一个开源框架，当你使用MVVM设计模式的时候，它几乎是你最好的选择，当然你也可以使用其他的一些方式来完成数据绑定，KVO，delegate或者是block，但是RAC为你提供了更优雅更安全的绑定方式，我们可以使用RAC在View和ViewModel中充当binder的角色来实现数据的同步，也可以把RAC放在ViewModel层，使用signal来异步获取数据，比如网络请求，访问数据库等。 因为RAC是一个使用起来并不那么容易的开源框架，所以接下来我会分几个部分来介绍它： FRP 的思想概要 （oop和fp） RAC 的 operations 介绍 冷信号与热信号解惑 生命周期指南 disposable 和多线程 实战分享 ReactiveCocoa是Gitbub开源的一个函数响应式编程框架，它是iOS上的函数响应式编程（FRP）体现，要理解RAC，首先我们就要理解函数响应式编程（FRP），刚开始接触FRP可能有一些困扰，因为它和我们以往的编程方式区别很大，接下来我们回顾一下现在常用的编程方式：面向对象编程（OOP）和面向协议编程（POP） ###面向对象编程（OOP从我们刚开始学习编程，接触到的最多就是面向对象编程（OOP），OOP的优点很多，继承，抽象，多态，可重用性，可维护性等等，我们从很早就知道了万物皆可盘（误 ，应该是万物皆对象的编程思想，当然有人也有一些质疑，比如结构体和对象的关系等，抛开这些争论，面向对象仍然是一种灵活的，易于维护的编程方式。 ###面向协议编程（POP）面向协议编程（POP）是我在使用Swift时用到的编程方式。我在15-16年中使用Swift来完成编程工作，现在因为一些原因我又回到了Objective-C阵营，但我仍无比的怀念Swift，其中一个重要原因，就是Swift对面向协议编程的友好支持。 苹果公司声明：从核心上说，Swift是面向协议的 POP拥有OOP的大部分特点，他们之间最大的区别是：类只能继承一个类（这里只讨论iOS开发语言，像一些编程语言比如C++的确拥有多继承，但是多继承在工作中仍然不是一个很好的特性），而类可以实现多个协议。我们可以举一个例子，如果现在要创建漫威英雄的类，我们要怎么创建？ 创建一个父类,拥有fly，land方法， SuperHero：fly（），land() 子类Super Man： 子类Iron Man： 子类Spider Man： 我们都知道小蜘蛛是没有飞行能力的，所以在这里将fly和land方法放在父类中并不可行，我们必须在父类删除fly和land，在超人和钢铁侠中单独加入fly和land，但是拥有飞行能力的超级英雄并不少见，我们接下来不得不为猎鹰，幻世，绯红女巫他们挨个加上。所以面向对象在这里并不是很可靠，换个思路，这里我们用POP试一下 创建一个fly协议，拥有fly和land两个方法，因为飞行和降落都是对应的，所以这里没有什么问题，接下来我们只要将拥有飞行能力的超级英雄实现fly协议，这样使用这个fly协议的超级英雄就拥有了飞行能力，当然我们也可以建立更多的协议，来为超级英雄增加更多的能力。 编程思想并没有孰优孰劣，我们这里只是做一个简单介绍，接下介绍一下今天的重点，函数响应式编程（FRP）。 ###函数响应式编程（FRP）FRP全称Function Reactive Programing，它包含了两个部分，函数式编程 Function Programing（FP）和响应式编程 Reactive Programing（RP）, ####响应式编程 我们先来看一段代码， int a = 3; int b = 5; int c = a + b; a = 8; NSLog(@“c = %d”, c); //8 这是我们熟悉的编程方式，首先为a和b进行赋值，然后将a + b的指赋给c，打印c的结果为8，接下来修改a和b的值后重新打印c，此时c的值仍然是8。因为代码中的 a + b只是一个瞬时的操作，并不是一段关系的描述。 而响应式编程是一种面向数据流和变化传播的编程范式，这意味着可以再编程语言中很方便的表达静态和动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播，所以在响应式编程中，上述例子中的c 会跟根据a、b值得变化而发生变化 在app的登录界面中，我们常常需要通过判断用户名和密码是否填写合法后来设置登陆按钮的可点击状态，这里我们可以对userNameTextField和passwordTextField进行监听，然后将监听的结果合并后进行合法性判断，最后将处理的结果绑定到登陆按钮上，这在RAC中是一个最常用的写法，当userNameTextField和passwordTextField发生变化时，登陆按钮的状态会相应的发生变化。 1234567891011RAC(self.viewModel, username) = self.usernameTexField.rac_textSignal;RAC(self.viewModel, password) = self.passwordTextField.rac_textSignal;self.validLoginSignal = [[RACSignal combineLatest:@[RACObserve(self, username), RACObserve(self, password)] reduce:^(NSString *username, NSString *password)&#123;return @(username.isExist &amp;&amp; password.isExist);&#125;] distinctUntilChanged];RAC(self.loginButton, enabled) = self.viewModel.validLoginSignal; ​​​ 另外一个典型的例子，在iOS开发中我们用Autolayout设置约束来描述视图之间的位置关系，当某一个约束发生改变后，其他的约束就会响应发生变化，这里也是响应式编程的体现。​​ ####函数式编程​​ 函数式编程将计算机运算视为函数运算，并且避免使用程序状态和易变对象，在函数式编程中函数可以像其他数据类型一样，处于平等的地位，可以作为参数传递到另一个函数中，可以赋值给其他的变量，也可以做为别的函数的返回值。​​ 我们可以使用RAC提供的一系列高阶函数来实现函数式编程，比如map，falltenMap,,filter,reduce,merge,combinte等等，在接下来的文章中我会介绍一下RAC为我们提供的常用的高阶函数。​​​ 到这里大家应该已经对FRP编程思想有一些认识，接下来我会介绍以下RAC为我们提供的高阶函数，已经如何如果使用它们来解决开发工作中可能遇到的一些问题。​​​​​​​​​​ 说了这么多，那么使用FRP到底有什么好处呢，我觉得使用FRP可以为我们解决以下几个问题：​​ 过多的状态值​​ vc中的冗余代码​​ 消息传递机制​​ Event之间的组合，交互​​ 多请求的处理​]]></content>
  </entry>
  <entry>
    <title><![CDATA[cocoaThinking重启计划]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF%2F</url>
    <content type="text"><![CDATA[我在2015年开通了自己的博客，博客通过hexo+github搭建，博客开通的虽早，但是写作确没有怎么坚持下来，2015年到现在零零散散的写了不到10篇，多数还是在15年趁着刚刚搭建完的热乎劲写成，实在汗颜。2019阴历新年马上就要到了，我决定制定一个cocoaThinking重启计划，一方面写一写技术总结，另一方面也有地方可以写一下日常的生活点滴。这次博客的重启，我更新了一些必要工具，hexo，node，npm，还有hexo的模板Next，更新的时候我发现node的版本从当时的0.10升级到了11.15，hexo和next也都完成多个版本的升级，不得不感慨时光匆匆，几年的时间过的真快，当时搭建博客的时候和我的同事showndu一起研究讨论问题的场景还是历历在目，这也更坚定了我对这次重启计划的决心。看了一下自己以前写的文章，多数因为年代久远已经过时了，剩下的几篇比如《iOS常用设计模式》，因为当时的自己较为年轻，写的文章也有很多不足。所以会对之前的文章进行清理，过时的删掉，不足的会进行修改补充。接下来先完成这部分工作吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS9 Search API NSUserActivity]]></title>
    <url>%2F2015%2F09%2F25%2FNSUserActivity%2F</url>
    <content type="text"><![CDATA[在WWDC2015会议上，苹果公布了iOS9系统，iOS9系统相比iOS7、iOS8并没有特别大得变化，可以看做是iOS8的基础上进行的平滑的过度。但是新的系统中仍有一些特性和功能值得人们去关注，其中Search API就是其中之一。通过新的Search API可以实现强大的应用内搜索功能，通过在Spotlight中使用我们设计的所以，来查看app中的界面或是内容。 iOS9的 Search API由三个组件组成：1.NSUserActivity2.Web Markup3.Core Spotlight现在介绍一下NSUserActivity的使用NSUserActivity是在iOS8中出现的API，主要用户HandOff功能，iOS9中NSUserActivity新增加了一个属性 eligibleForSearch 来控制在Spotlight中的显示 定义一个NSUserActivity属性1@property (nonatomic, strong)NSUserActivity *activity; 初始化NSUserActivity,并设置属性1234567891011121314151617//ActivityType为唯一标识_activity = [[NSUserActivity alloc]initWithActivityType:@&quot;Eden&quot;];//title app在Spotlight中显示的名称，可以和app名称不一样，多个app使用相同的keywords，初始通过title名称进行排序_activity.title = @&quot;Eden&quot;;//Spolight搜索关键字_activity.keywords = [NSSet setWithArray:@[@&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Eve&quot;]];//关闭HandOff功能_activity.eligibleForHandoff = NO;//开启Spotlight search功能_activity.eligibleForSearch = YES;//开启NSUserActivity[_activity becomeCurrent]; 当做完这些操作时候然后运行程序，我们在spotlight中搜索 adam, lilith, eva中的某一个关键字就会找到我们的应用，此时选择应用会直接跳转到app的首页。有时候我们希望最好能通过某个关键字直接跳转到app其中某一页，幸运的是NSUserActivity同样支持这个功能。 准备工作：创建AdmaViewController，LilithViewController我们在AdmaViewController中创建adamUserActivity,title为adamView, 关键字adam我们在LilithViewController中创建lilithUserActivity, title为lilithView,关键字lilith可以在首页通过adam跳转到admaViewController可以在首页通过lilith跳转到lilithViewController 开始工作：找到AppDelegate文件，添加方法 //在主线程下存在可用NSUserActivity对象时候调用123456789- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123;//找到当前的window的rootView转换为UINavigationController(如果你的rootView是UINavigationController的话) UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;//找到navigationController的topView（首页） 中restoreUserActivityState方法 [navigationController.topViewController restoreUserActivityState:userActivity]; return YES;&#125; 在首页中重写restoreUserActivityState方法 1234567891011121314- (void)restoreUserActivityState:(NSUserActivity *)activity&#123;//通过Spotlight中传过来的NSUserActivity对象的title判断具体跳转到哪一页 if ([activity.title isEqualToString:@&quot;Adam&quot;]) &#123; AdamViewController *adamView = [[AdamViewController alloc]init]; [self.navigationController pushViewController:adamView animated:YES]; &#125;else if([activity.title isEqualToString:@&quot;Lilith&quot;])&#123; LilithViewController *lilithView = [[LilithViewController alloc]init]; [self.navigationController pushViewController:lilithView animated:YES]; &#125;else if([activity.title isEqualToString:@&quot;Eve&quot;])&#123; EveViewController *eveView = [[EveViewController alloc]init]; [self.navigationController pushViewController:eveView animated:YES]; &#125;&#125; 现在当选择再Spotlight中搜索adam，选择应用会直接跳转到 adamViewController中，搜索lilith关键字，选择应用会直接跳转到lilithViewController中 本文代码下载地址]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS9</tag>
        <tag>Search API</tag>
        <tag>NSUserActivity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSArray和NSMutableArray]]></title>
    <url>%2F2015%2F08%2F26%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组作为存储对象的有序集合，可能是平时用到的最多的集合类。NS数组中存放的是Fundation对象，简单类型比如int，float等可以封装为NSNumber对象来存放到数组中。Objc中数组分为不可变数组和可变数组，可变数组使用NSMutableArray来处理，不可变数组为NSArray，NSMutableArray是NSArray的子类，也就是说继承了NSArray得所有方法 1.创建一个数组创建一个NSArray1234567NSArray *array = [NSArray arrayWithObjects:@1, @2, @3, nil];NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:10];NSMutableArray *array2 = [NSMutableArray array];NSMutableArray *array1 = [[NSMutableArray alloc]initWithCapacity:0]; 使用initWithCapacity方法可以在初始化数组的时候添加一个预留空间，在数组空间超过这个预留空间时候会进行自动追加。不过是再测试中发现这样做并没有提高应有的效率，传言苹果实际上没有采用这个参数。不过这样有个好处是可以做为一个隐性文档来提高代码可读性。 在创建NSArray数组的时候也可以使用语法糖，相对于调用方法更加简单快捷1NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;]; 2.NSArray 和NSMutableArray 转换//NSMutableArray 转换NSArray12345// 创建可变数组NSMutableArray *mutableArray = [NSMutableArray array];// 使用copy方法获得一个NSArray。使用三木运算符判断当NSArray为nil时候重新初始化一个新的对象// x?:y == x?x:y; NSArray *array = [mutableArray copy]?:[NSArray array]; //NSArray 转换NSMutableArray123456//初始化一个NSArrayNSArray *array = @[@7, @2 ,@0 ,@1, @6, @8, @3] ;// 使用mutableCopy方法获得一个NSMutableArrayNSMutableArray *mutableArray = [array mutableCopy]?:[NSMutableArray array];//使用类方法arrayWithArray进行转换NSMutableArray *mutableArray2 = [NSMutableArray arrayWithArray:array]; 3.查找对象1id object = [array objectAtIndex:index]; 同样可以通过语法糖获取1id object = array[index]; NSArray提供firstObject, lastObject,方法获取数组的首尾对象，当数组为空时候返回nil。而使用常规方法获取空数组中的对象则会返回NSRangeException异常12id lastObject = [array lastObject];id firstObject = [array firstObject]; 为了方便数组中数据量很大的情况下查找数据，苹果已经预先实现二分查找法来遍历数组，这样查询效率将大大提高12345678910NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];NSMutableArray *mutableArray = [NSMutableArray array];NSRange range = NSMakeRange(0, 5);NSInteger index = [array indexOfObject:@0 inSortedRange:range options:NSBinarySearchingInsertionIndex usingComparator:^NSComparisonResult(id obj1, id obj2) &#123; if (obj1 &lt; obj2) &#123; return NSOrderedAscending; &#125; return NSOrderedDescending;&#125;];id object = mutableArray[index]; 4.排序有很多方法可以对数组进行排序，如果数组中存放的是字符串对象，可以使用sortedArrayUsingSelector:方法进行排序12NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;];NSArray *newArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)]; 如果数组存放的是数字，可以使用compare:方法进行排序12NSArray *array = @[@4, @0, @8, @9, @11];NSArray *newArray = [array sortedArrayUsingSelector:@selector(compare:)]; 可是使用reverseObjectEnumerator.allObjects获得一个数组的逆序排列12NSArray *array = @[@4, @0, @8, @9, @11];NSArray *newArray = array.reverseObjectEnumerator.allObjects; 5.枚举从一个数组过滤一些元素，组成另一个数组使我们经常遇到的一个场景，同样Objc提供了很多方法可以实现1.快速枚举 NSFastEnumeration(for in)使用快速枚举在数组数据量较大的情况下效率会比传统的for循环提高很多，而且快速枚举代码的可读性也更高1234567NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];NSMutableArray *newArray = [NSMutableArray array];for (NSString *godName in array) &#123; if ([godName containsString:@&quot;l&quot;]) &#123; [newArray addObject:godName]; &#125; &#125;NSLog(@&quot;%@&quot;,newArray); 2.使用indexesOfObjectsWithOptions方法当数据量很大的情况下，使用indexesOfObjectsWithOptions方法的NSEnumerationConcurrent参数可以开启同步执行，但这也只是在数据量很大的情况下，当数据量较少时候因为需要额外的线程管理效率会变得更低一些123456789101112NSArray *array = @[@&quot;Eve&quot;, @&quot;Adam&quot;, @&quot;Lilith&quot;, @&quot;Lilin&quot;, @&quot;Satan&quot;, @&quot;Lilim&quot;];NSIndexSet *indexSet = [array indexesOfObjectsWithOptions:NSEnumerationConcurrent passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) &#123; if ([obj isKindOfClass:[NSString class]]) &#123; NSString *godName = obj; if ([godName containsString:@&quot;l&quot;]) &#123; return obj; &#125; &#125; return nil; &#125;];NSArray *newArray = [array objectsAtIndexes:indexSet];NSLog(@&quot;%@&quot;,newArray);]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS常用设计模式]]></title>
    <url>%2F2015%2F08%2F12%2FiOS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[所有的iPhone应用程序都是基于UIKit框架构建而成的，所以它们在本质上具有相同的核心架构。 UIKit框架的设计模式 结合了很多在Mac OS X Cocoa应用程序中使用的设计模式，理解这些设计模式对于创建iPhone程序是很关键的。 1.模型-视图-控制器模式 MVC模式模型-视图-控制器模式(model-view-controller)简称MVC模式，它将您的代码独立分割为几个部分。模型部分定义应用程序的数据引擎，负责维护数据的完整性；视图定义应用程序的用户界面；控制器则充当模型和视图的桥梁，负责实现数据和现实的更新。 2.目标-动作控件通过目标-动作的模式将用户的交互通知您的应用程序，当用户以预先定义好的动作（比如点击一个按钮）进行交互时，空间就会将消息（动作）发送给您制定的对象（目标）。接收到动作消息后，目标对象就会以恰当的方式相应（比如按动按钮的时候刷新应用程序的状态）。 3.单例模式单例模式确保一个给定类只有一个实例出现，这个实例有一个全局的访问点，它通常使用懒加载的时候在第一次使用的时候再取加载注意：苹果使用了大量的单例模式，我们用到的[UIAppliacation shareapplication],[UIScreen mainscreen],[NSUserDefaults standardUserDefaults] 等返回的都是一个单例对象。在一些情况下使用单例模式会是非常合理的，比如你需要一个全局配置处理类，使用单例模式就会很好的实现。使用GCD的方式可以很容易实现一个单例模式 1234567891011+(Singelton)shareInstance&#123; // 1 static Singelton *st; // 2 static dispatch_once_t onceToken; // 3 dispatch_once(&amp;onceToken,^&#123; st =[[Singelton alloc]init]; &#125;); return st;&#125; 在这段代码中有三个需要注意的地方： 声明一个static静态变量保存实例变量，确保它在类中的全局可用性。 声明一个static静态dispath_once_t，确保初始化代码只执行一次 使用 Grand Center Dispatch (GCD)执行Singelton变量block，正式单例模式的关键，一旦类被初始化，初始化器就不会再被调用下次再调用shareInstance的时候，dispatch_once块中得代码将不会执行（因为他已经被执行了一次），你将得到已经初始化好的类 4.代理设计模式代理设计模式 一个对象提供机会对另一个对象发生变化时候做出反应。代理模式基本思想：两个对象协同解决问题，通常用于对象之间的通信 Cocoa 框架中同样运用了大量的代理模式，每个UI控件后边都声明了一个id类型的delegate或是datasource，比如说最常用到的UITableView 控件头文件中声明了：12@property (notamatic, assign)id &lt;UITableViewDataSource&gt; datasource; @property (notamatic, assign)id &lt;UITableViewDelegate&gt; delegate; 即这个代理要遵循某一个协议。]]></content>
  </entry>
</search>
